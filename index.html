<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="lylex&#39;s humble Home">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lylex&#39;s humble Home">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lylex&#39;s humble Home">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>lylex's humble Home</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lylex's humble Home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/15/singleton-thread-safe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lylex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lylex's humble Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/singleton-thread-safe/" itemprop="url">
                  一个线程安全的Singleton
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-15 21:10:25" itemprop="dateCreated datePublished" datetime="2018-08-15T21:10:25-06:00">2018-08-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-26 03:27:41" itemprop="dateModified" datetime="2018-12-26T03:27:41-07:00">2018-12-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一个线程安全的Singleton"><a href="#一个线程安全的Singleton" class="headerlink" title="一个线程安全的Singleton"></a>一个线程安全的Singleton</h2><p>看到一段Singleton的代码，比较与众不同，问题来了，这究竟是不是线程安全的呢？先看代码吧(原来代码是模板的，为了简单起见，做了一个阉割，用int来代替了)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CreateUsingNew</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span>* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span>&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s_instance) &#123;</span><br><span class="line">            create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *s_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *instance = __sync_val_compare_and_swap(&amp;s_instance, s_instance, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">            CreationPolicy::destroy(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line"></span><br><span class="line">    ~Singleton() &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *temp = CreationPolicy::create();</span><br><span class="line">        <span class="keyword">int</span> *old = __sync_val_compare_and_swap(&amp;s_instance, <span class="literal">NULL</span>, temp);</span><br><span class="line">        <span class="keyword">if</span> (old) &#123;</span><br><span class="line">            CreationPolicy::destroy(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>* s_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* Singleton::s_instance = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonAccessor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~SingletonAccessor() &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Singleton::destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;Singleton::instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton::instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">int</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;Singleton::instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先不忙着急回答这个问题，我们先来回顾下一些基本的关于Singleton的基本知识吧，希望回顾之后能够不证自明、水到渠成。</p>
<h1 id="Singleton的实现"><a href="#Singleton的实现" class="headerlink" title="Singleton的实现"></a>Singleton的实现</h1><p>大面上讲，Singleton模式在C++中的实现分成两种思路，分别叫做“懒汉模式”和“饿汉模式”。所谓“懒汉”和“饿汉”，只是针对分配资源的时机而言，“懒汉”嘛，就是比较懒，只有用到这个资源的时候才分配，“饿汉”嘛，就是饿死鬼投胎、生怕一会没得吃，先吃下去的那种，也就是预先分配好资源。</p>
<h2 id="饿汉实现"><a href="#饿汉实现" class="headerlink" title="饿汉实现"></a>饿汉实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Singleton* m_instance;</span><br><span class="line"></span><br><span class="line">  Singleton()&#123;&#125;</span><br><span class="line">  Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::m_instance = <span class="keyword">new</span> Singleton;</span><br></pre></td></tr></table></figure>
<p>饿汉模式是相对比较简单的，而且没有线程安全性问题，因为它在进入main函数之前就已经初始化好了，处于全局数据区。</p>
<h2 id="懒汉实现"><a href="#懒汉实现" class="headerlink" title="懒汉实现"></a>懒汉实现</h2><p>相对于饿汉模式，懒汉模式稍微复杂点，看看经典实现吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock();</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        m_instance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock();</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> Singleton *m_instance ;</span><br><span class="line"></span><br><span class="line">  Singleton() &#123;&#125;</span><br><span class="line">  Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton:: m_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，基本是类似的，除了初始化m_instance的时间点不同，这里只有来getInstance时候，而且从来没有构造过的情况下，才会去创建。</p>
<p>注意到了这么一个情况，就是在getInstance函数中，判断m_instance是否为NULL前后的block中是要加锁的。为什么要有这样的锁呢，当然是为了所谓的线程安全了。如果不这样的话呢，假设m_instance没有被初始化过，而且两个线程同时进入判断其是否为空的代码块，接着就会出现两个对象同时被创建的情况，那就不是Singleton了。所以呢，这个锁是合理的。</p>
<p>那有人就要问了，这个锁是不是真的就一定非加不可呢？毕竟加锁了，肯定是影响性能的了。好吧，还真未必，如果是使用C++11的话，这个锁真的就可以省却了，请看如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton *<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">static</span> Singleton m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  Singleton() &#123;&#125;</span><br><span class="line">  Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">  Singleton&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个也是线程安全的，因为c++0x之后，要求编译器保证内部静态变量的线程安全性，也就是说即便两个线程同时判定m_instance为NULL，也只会初始化一个m_instance。当然了，不能保证这段代码会在C++11以上标准兼容的编译器中编译，也不能保证所有的编译器都已经执行了这个稍稍新一点的标准，安全起见，还是加上这个锁吧。</p>
<h1 id="原子操作下的线程安全性"><a href="#原子操作下的线程安全性" class="headerlink" title="原子操作下的线程安全性"></a>原子操作下的线程安全性</h1><p>回看我们的一开始的那个程序，其核心部件如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s_instance) &#123;</span><br><span class="line">        create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *temp = CreationPolicy::create();</span><br><span class="line">    <span class="keyword">int</span> *old = __sync_val_compare_and_swap(&amp;s_instance, <span class="literal">NULL</span>, temp);</span><br><span class="line">    <span class="keyword">if</span> (old) &#123;</span><br><span class="line">        CreationPolicy::destroy(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设两个线程同时使用一个没有初始化的s_instance，同时调用create()，那么都创建了一个temp，开始执行<code>__sync_val_compare_and_swap</code>这句话。</p>
<p><code>type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</code>是个原子操作，比较ptr对应的值是不是跟oldval相等，如果相等，那么就给ptr写入newval，如果不等，就算了，什么也不做，无论如何，最后返回原来操作以前的值。对于这个原子操作而已，凡是总有先后，一个线程提前一点点进入了，将temp写进去了，那么此时的old1就是NULL，而下一个线程进入的时候，s_instance已经被初始化了，发现已经不是NULL了，此时它啥也不做，只是默默地返回原来的old，也即是第一个线程写进去的那个，接下来，old有值了，如果old有值，那么就将本次分配的temp销毁掉，因而，后面的线程其实啥也没有留下。因此说，这个是线程安全的。</p>
<p>由此可见，用了一个简单的原子操作，就可以免去锁的烦恼，还是很妙的！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/cpp-template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lylex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lylex's humble Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/cpp-template/" itemprop="url">
                  从一段代码来看C++模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-09 21:21:20" itemprop="dateCreated datePublished" datetime="2018-08-09T21:21:20-06:00">2018-08-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-26 03:27:41" itemprop="dateModified" datetime="2018-12-26T03:27:41-07:00">2018-12-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="从一段代码来看C-模板"><a href="#从一段代码来看C-模板" class="headerlink" title="从一段代码来看C++模板"></a>从一段代码来看C++模板</h2><p>最近在看C++的项目，看到了一段关于C++模板的代码，方才知道几年没有写C++，曾经费尽心思学的那些个C++模板的知识已经还掉了。不管怎么样，C++的泛型编程还是很强大的，省却了若干重复代码，赋予了C++元编程的能力，因此，还是要学的。这段代码基本囊括了模板的点点滴滴，正好可以用来恢复点记忆吧。一起来学学：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">CreateUsingNew</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span> &lt;class&gt; <span class="title">class</span> <span class="title">CreationPolicy</span> = <span class="title">CreateUsingNew</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s_instance) &#123;</span><br><span class="line">            create();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *s_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T *instance = (T*)atomic_compare_and_swap(&amp;s_instance,s_instance,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">            CreationPolicy&lt;T&gt;::destroy(instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line"></span><br><span class="line">    ~Singleton() &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T *temp = CreationPolicy&lt;T&gt;::create();</span><br><span class="line">        T *old = atomic_compare_and_swap(&amp;s_instance, <span class="literal">NULL</span>, temp);</span><br><span class="line">        <span class="keyword">if</span> (old) &#123;</span><br><span class="line">            CreationPolicy&lt;T&gt;::destroy(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> T* ptr_type;</span><br><span class="line">    <span class="keyword">static</span> ptr_type s_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span> &lt;class&gt; <span class="title">class</span> <span class="title">CreationPolicy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Singleton</span>&lt;T, CreationPolicy&gt;:</span>:ptr_type Singleton&lt;T, CreationPolicy&gt;::</span><br><span class="line">    s_instance = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果看完之后，你跟我一样心里是一万个草泥马飘过的话，那好，证明我们是同道中人。代码已经看过了，至于里面的条条框框我们先不急，我们先一一将C++的几个知识点串一串，希望之后那些硬骨头会不攻自破。</p>
<h1 id="一个典型的模板"><a href="#一个典型的模板" class="headerlink" title="一个典型的模板"></a>一个典型的模板</h1><p>模板大致又在实用中分成函数模板（function template）和类模板（class template）。我们上面的例子只是提及了类模板，没有函数模板，关于类模板成员函数的定义也还是属于类模板的范畴。</p>
<p>以下，来看一个关于类模板和函数模板的示例吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; t1, T&amp; t2)</span> </span>&#123;</span><br><span class="line">  T tmp;</span><br><span class="line">  tmp = t1;</span><br><span class="line">  t1 = t2;</span><br><span class="line">  t2 = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Swaper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; t1, T&amp; t2)</span> </span>&#123;</span><br><span class="line">    T tmp;</span><br><span class="line">    tmp = t1;</span><br><span class="line">    t1 = t2;</span><br><span class="line">    t2 = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上先是定义了一个模板函数swap，用于任意类型的交换，接着又定义了一个功能类似的Swaper模板类。在template后的尖括号<code>&lt;&gt;</code>中，两个模板分别使用了<code>typename</code>和<code>class</code>，实际上，二者是等效的，大体上讲，class是历史原因因而保留，推荐使用typename，两者都表示类型参数。注意，类模板中，struct默认是<code>public</code>的，而class默认是<code>private</code>的，所以这里的Swaper的swap成员函数是<code>public</code>的。</p>
<p>回到我们一开始的那个例子吧，<code>CreateUsingNew</code>就是一个算是典型的简单类模板了，这就没有什么可说道的了。关于第二个<code>Singleton</code>类模板的类型参数有点不一样，具体解释看下一节吧。</p>
<h1 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h1><p>看例子中的这段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span> &lt;class&gt; <span class="title">class</span> <span class="title">CreationPolicy</span> = <span class="title">CreateUsingNew</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子中，短短的一行代码，涉及了一下模板知识：</p>
<h2 id="多模板参数"><a href="#多模板参数" class="headerlink" title="多模板参数"></a>多模板参数</h2><p>模板参数可以不止一个，这个很好理解啊，因为很多场景下，一个函数或者类中，有多个需要变化的类型，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">maxSize</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> C&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxT = <span class="keyword">sizeof</span>(t);</span><br><span class="line">    <span class="keyword">int</span> maxC = <span class="keyword">sizeof</span>(c);</span><br><span class="line">    <span class="keyword">return</span> maxT &gt; maxC ? maxT : maxC;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; t.maxSize(d, i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板型参数"><a href="#模板型参数" class="headerlink" title="模板型参数"></a>模板型参数</h2><p>所谓模板型参数，就是指模板的类型参数中，有一个或多个是模板，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">someclass</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// someclass&lt;int, Test&lt;int&gt;&gt; s;</span></span><br></pre></td></tr></table></figure>
<p>使用的时候，要将模板参数先进行实例化，例如上面例子中的<code>Test&lt;int&gt;</code>，然后<code>Test&lt;int&gt;</code>整体作为someclass的参数。回到我们的开始之后的那个例子，<code>CreationPolicy</code>实际就是一个模板，然后再作为模板参数。不过，它后面的等于号是什么呢，接着往下看：</p>
<h2 id="模板参数默认值"><a href="#模板参数默认值" class="headerlink" title="模板参数默认值"></a>模板参数默认值</h2><p>还是来看这个例子，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span> &lt;class&gt; <span class="title">class</span> <span class="title">CreationPolicy</span> = <span class="title">CreateUsingNew</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>template &lt;class&gt; class CreationPolicy = CreateUsingNew</code>其实是作为这个模板的默认参数存在的，那么，什么是默认参数呢，顾名思义，就是类似函数的默认参数一样。需要特别注意的是，这个是C++11之后才有的特性。我们来看一个简单的例子吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="keyword">int</span>&gt;</span><br><span class="line">class DefaultParam &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultParam&lt;&gt; d;</span><br></pre></td></tr></table></figure>
<p>上面的这个例子就是默认值是int，这里有个需要注意的是，在实例化的时候，默认值后面的&lt;&gt;千万不要省略。</p>
<p>事实上，我们开头给出的那个例子中<code>template &lt;class&gt; class CreationPolicy = CreateUsingNew</code>给出的是一个策略（policy）。所谓策略，一般是一个类模板，典型的策略是 STL 容器（如 std::vector&lt;&gt;，完整声明是template&lt;class T, class Alloc=allocator<t>&gt; class vector;）的分配器（这个参数有默认参数，即默认存储策略），策略类将模板的经常变化的那一部分子功能块集中起来作为模板参数，这样模板便可以更为通用，这和特性的思想是类似的。</t></p>
<h1 id="禁用类默认生成的函数"><a href="#禁用类默认生成的函数" class="headerlink" title="禁用类默认生成的函数"></a>禁用类默认生成的函数</h1><p>众所周知，当编译检测到一个类有定义时(注意，空类是不会生成任何成员函数的，只有被使用、也就是被定义了才会)，就会为它生成几个成员函数（如果这个类恰好没有定义的话）：默认构造函数，析构函数，拷贝构造函数，赋值构造函数。</p>
<p>即如下函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line"></span><br><span class="line">    ~Singleton() &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果在我们的一开始的程序中没有出现的话，那么编译器一旦发现这个类被使用了，那么是会给他定义的。可是，现在这四个函数都被设置成了private，设置成pravite意味着除了在类的成员函数中，其他情况都不可以访问，这几个本来在public中才能使用的函数被设置成了private，也就意味着这几个函数都不能被外界使用了呗，也就实现了禁用了。</p>
<p>一个类既然不能构造，不能析构了，那还有什么用呢？哦，其实也不是完全的不能构造了，我们的程序又给他们定义了两个public static函数<code>create</code>和<code>destroy</code>，作为其wrapper，便替代了构造和析构的功能。</p>
<h1 id="类模板静态成员变量的初始化"><a href="#类模板静态成员变量的初始化" class="headerlink" title="类模板静态成员变量的初始化"></a>类模板静态成员变量的初始化</h1><p>类的静态成员变量是个特别的存在，所有类的instance共享一份，而它的所有者却是类本身。它没有this指针，对象可以调用它，类也可以直接调用它。所以说呢，它看上去更像一个独特的全局变量，因而它只能在类定义体之外初始化。</p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">key</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">string</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> key::_y = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure>
<p>模板是要最终被编译器解析成代码的，那模板类的静态成员变量又是归属谁呢？试想一下，比如单参数模板，一种参数类型对应于一个类实现，那么，必然是这个类实现拥有其对应的静态成员变量的归属权了。</p>
<p>我们再回过头来看看开头的这段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">template</span> &lt;class&gt; <span class="title">class</span> <span class="title">CreationPolicy</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">Singleton</span>&lt;T, CreationPolicy&gt;:</span>:ptr_type Singleton&lt;T, CreationPolicy&gt;::</span><br><span class="line">    s_instance = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这下了然了，就是<code>Singleton&lt;T, CreationPolicy&gt;::ptr_type</code>类型的<code>Singleton&lt;T, CreationPolicy&gt;::s_instance</code>静态成员变量的初始化而已了，都给写完整了就有点唬人了。</p>
<p>接下来，有人要问了，前面加的<code>typename</code>是什么意思？事实上省略了也是读的通的，只是为了避免如下的尴尬：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContainsAnotherType</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> iterator;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo&lt;ContainsAnotherType&gt;();</span><br></pre></td></tr></table></figure>
<p>然后，<code>T::iterator * iter;</code>被编译器实例化为<code>ContainsAnotherType::iterator * iter;</code>，这就有歧义了，这是乘法呢，还是一个定义呢？</p>
<p>所以说，为了避免歧义，依赖模板参数才能确定的那些类型名字，都要加上<code>typename</code>。下面就是一些典型的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>() &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> T::iterator iter;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">foo</span>() &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> T::iterator iterator_type;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/liangliangh/p/4219879.html" target="_blank" rel="noopener">C++模板元编程</a></li>
<li><a href="http://feihu.me/blog/2014/the-origin-and-usage-of-typename/" target="_blank" rel="noopener">typename的起源与用法</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/02/cpp-atomic-functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lylex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lylex's humble Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/02/cpp-atomic-functions/" itemprop="url">
                  C++原子操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-02 02:41:20" itemprop="dateCreated datePublished" datetime="2018-08-02T02:41:20-06:00">2018-08-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-26 03:27:41" itemprop="dateModified" datetime="2018-12-26T03:27:41-07:00">2018-12-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在一般的C++程序中，通篇看，没有多少常见的操作是原子操作的。一般的逻辑处理当然没有问题，可是当涉及多线程的时候，就不安全了，例如访问计数<code>count++</code>这个简单的操作，你能保证它是原子的嘛？显然不能的。<br>或许你会想到，使用锁啊。这是能解决问题，不过其性能可想而知。<br>好在C++内置了一系列的基础计算函数，确保是原子的，这里头涉及了一些处理器相关的知识或技术，我们且不去深究了，我们来从使用者的角度，来看看他们的定义和用法吧。</p>
<h1 id="n-式"><a href="#n-式" class="headerlink" title="n++式"></a>n++式</h1><p>这类函数对传入指针指定的内存进行数值操作，操作完将数值填入指针指向内存，但返回指针指向的内存的原始值，就像我们经常遇到的<code>n++</code>一样，n加一了，最终返回加一前的n。具体函数列表如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)  <span class="comment">// +</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)  <span class="comment">// -</span></span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)   <span class="comment">// |</span></span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)  <span class="comment">// &amp;</span></span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)  <span class="comment">// ^</span></span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...) <span class="comment">// (~m)^n</span></span><br></pre></td></tr></table></figure>
<p>就拿<code>__sync_fetch_and_add</code>举例吧，这个相当于如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp = *ptr;</span><br><span class="line">*ptr += value;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br></pre></td></tr></table></figure>
<p>举个实际使用的例子吧，也拿<code>__sync_fetch_and_add</code>说事，其他也差不多了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">auto</span> x = __sync_fetch_and_add(&amp;n, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="n式"><a href="#n式" class="headerlink" title="++n式"></a>++n式</h1><p>同样的，这样的函数就对应<code>++n</code>这种形式，即每次操作完了，返回操作后的值。列表如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br></pre></td></tr></table></figure>
<p>同样拿最简单的<code>__sync_add_and_fetch</code>举例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">auto</span> x = __sync_add_and_fetch(&amp;n, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Compare-and-Swap"><a href="#Compare-and-Swap" class="headerlink" title="Compare-and-Swap"></a>Compare-and-Swap</h1><p>这个对应于一个需求，查看某个值有没有被改过，改过就算了，没有改过的话，就来修改下它吧。列表如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br></pre></td></tr></table></figure>
<p>都是比较ptr对应的值是不是跟oldval相等，如果相等，那么就给<em>ptr写入newval，区别就是bool版本是newval成功写入了就返回true，而type版本返回</em>ptr操作前的值。</p>
<h1 id="Memory-barrier"><a href="#Memory-barrier" class="headerlink" title="Memory barrier"></a>Memory barrier</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__sync_synchronize (...) <span class="comment">// 获得一个full memory barrier.</span></span><br><span class="line"></span><br><span class="line">type __sync_lock_test_and_set (type *ptr, type value, ...) <span class="comment">// 将value写到*ptr，返回写之前的*ptr，获得一个acquire barrier</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sync_lock_release (type *ptr, ...) <span class="comment">// 用于释放__sync_lock_test_and_set加的锁，并将*ptr全部写0，获得一个release barrier</span></span><br></pre></td></tr></table></figure>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上原子操作只能一次更新或读取一个内存单元，如果涉及多个内存单元一起修改的时候，就只能加锁了，这些原子操作爱莫能助了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>  <a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/google-cpp-style/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lylex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lylex's humble Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/26/google-cpp-style/" itemprop="url">
                  《Google C++风格指南》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-07-26 19:48:16" itemprop="dateCreated datePublished" datetime="2018-07-26T19:48:16-06:00">2018-07-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-26 03:27:41" itemprop="dateModified" datetime="2018-12-26T03:27:41-07:00">2018-12-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《Google-C-风格指南》读书笔记"><a href="#《Google-C-风格指南》读书笔记" class="headerlink" title="《Google C++风格指南》读书笔记"></a>《Google C++风格指南》读书笔记</h2><p>近日开始看一个C++项目，看着某些代码风格非常不爽，于是乎三番两次对照Google C++的风格，生怕给带歪了。慢慢地就有了把这个中文译文给通读一遍的冲动。顺便记下笔记，算是沉淀知识，方便自己日后快速查阅，如果侥幸能够帮助到其他人，那真是太好了。</p>
<h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/" target="_blank" rel="noopener">头文件</a></h1><ol>
<li><p>一个source文件要有一个与之对应的header文件，以此来实现接口实现分离</p>
</li>
<li><p>每个头文件必须要有头文件保护，避免重复包含</p>
<blockquote>
<p>举个例子，假设foo项目中foo/src/bar/baz.h文件，那么这个头文件应当这么写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOO_BAR_BAZ_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_BAR_BAZ_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// FOO_BAR_BAZ_H_</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>不要使用前置声明</p>
<blockquote>
<p>所谓前置声明就是只有申明没有定义的类、函数、模板</p>
</blockquote>
</li>
<li><p>不要内联超过10行的函数</p>
<blockquote>
<p>内联函数会被编译器展开，滥用导致变慢，虚函数和递归函数即使内联也不会生效；一般来讲，定义在头文件类定义内的函数一般都会被内联，因此，注意不要在类定义中写过长的函数</p>
</blockquote>
</li>
<li><p>头文件包含顺序为：直接相关的文件，C库，C++库，其他库的.h，本项目内的.h</p>
<blockquote>
<p>所谓直接相关文件，就比如说<code>dir/foo.cc</code>中，foo.h就是直接相关的;<br>举例来说, google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/fooserver.h"</span> <span class="comment">// 优先位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hash_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/basictypes.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"base/commandlineflags.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo/public/bar.h"</span></span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>文件中所有用到的头文件都要被显式包含</p>
<blockquote>
<p>比如要用到<code>bar.h</code>中的一些符号，而已经包含的<code>foo.h</code>已经包含了<code>bar.h</code>，也得在文件中显式包含<code>bar.h</code></p>
</blockquote>
</li>
</ol>
<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/" target="_blank" rel="noopener">作用域</a></h1><ol>
<li><p>禁止使用using指示用于自定义命名空间，禁止使用内联命名空间，禁止使用命名空间别名</p>
</li>
<li><p>命名空间定义最后注释中给出其名字，内部定义不需要使用缩进</p>
<blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有声明都置于命名空间中</span></span><br><span class="line"><span class="comment">// 注意不要使用缩进</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// .cc 文件</span></span><br><span class="line"><span class="keyword">namespace</span> mynamespace &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义都置于命名空间中</span></span><br><span class="line"><span class="keyword">void</span> MyClass::Foo() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace mynamespace</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在<code>.cc</code>文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为<code>static</code>。但是不要在<code>.h</code>文件中这么做。</p>
<blockquote>
<p>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 static 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。匿名命名空间说白了就是文件作用域。</p>
</blockquote>
</li>
<li><p>使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. </p>
</li>
<li><p>相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用命名空间</p>
<blockquote>
<p>例如，对于<code>myproject/foo_bar.h</code>，应当使用如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>而不是这样</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化，离第一次使用越近越好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i = f(); <span class="comment">// 坏——初始化和声明分离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = g(); <span class="comment">// 好——初始化时声明</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>); <span class="comment">// 用花括号初始化更好</span></span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 好——v 一开始就初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>属于<code>if</code>, <code>while</code>和<code>for</code>语句的变量应当在这些语句中正常地声明，以限制其作用域最小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="built_in">strchr</span>(str, <span class="string">'/'</span>)) str = p + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止定义静态生存周期非POD变量</p>
<blockquote>
<p>静态生存周期变量包括：全局变量, 静态变量, 静态类成员变量, 以及函数静态变量, 都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体，即完全禁用 vector (使用 C 数组替代) 和 string (使用 const char [])。</p>
</blockquote>
</li>
<li><p>多线程中的全局变量 (含静态成员变量) 不要使用 class 类型 (含 STL 容器), 避免不明确行为导致的 bug</p>
</li>
</ol>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/" target="_blank" rel="noopener">类</a></h1><ol>
<li><p>不要在构造函数中调用虚函数，也不要在无法报出错误时候进行可能失败的初始化。</p>
<blockquote>
<p>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患。构造函数很难上报错误。</p>
</blockquote>
</li>
<li><p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用<code>explicit</code>关键字。</p>
</li>
<li><p>不要使用隐式产生的拷贝构造函数和移动构造函数，禁用他们或者给出定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass is neither copyable nor movable. 实施了禁用</span></span><br><span class="line">MyClass(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyClass&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>仅当只有数据成员时使用<code>struct</code>, 其它一概使用<code>class</code>.</p>
</li>
<li><p>所有继承必须是<code>public</code>的, 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
</li>
<li><p>优先考虑组合而非继承</p>
<blockquote>
<p>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承</p>
</blockquote>
</li>
<li><p>避免使用多重继承</p>
<blockquote>
<p>只有当所有父类除第一个外都是”纯接口类”时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以<code>Interface</code>为后缀.</p>
</blockquote>
</li>
<li><p>满足以下条件的类以<code>Interface</code>为后缀结尾</p>
<ul>
<li>只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承.</li>
</ul>
</li>
<li><p>尽量不要重载运算符</p>
</li>
<li><p><strong>所有</strong>数据成员声明为<code>private</code>, 除非是<code>static const</code>类型成员</p>
</li>
<li><p>类定义的顺序为：<code>public:</code>, <code>protected:</code>, <code>private:</code></p>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/functions/" target="_blank" rel="noopener">函数</a></h1><ol>
<li><p>函数的参数顺序为: 输入参数在先, 后跟输出参数.</p>
</li>
<li><p>函数要尽量简短，最好不要超过40行</p>
</li>
<li><p>所有按引用传递的参数必须加上<code>const</code>.</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入参数是值参或 const 引用, 输出参数为指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;in, <span class="built_in">string</span> *out)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 一般更推荐函数重载。</p>
<blockquote>
<p>严格点讲，应当禁止使用缺省函数参数，尽可能使用函数重载</p>
</blockquote>
</li>
</ol>
<h1 id="来自Google的奇技"><a href="#来自Google的奇技" class="headerlink" title="来自Google的奇技"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/magic/" target="_blank" rel="noopener">来自Google的奇技</a></h1><ol>
<li><p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<blockquote>
<p><code>std::unique_ptr</code>用来表示动态分配出的对象的独一无二的所有权; 当<code>std::unique_ptr</code>离开作用域时, 对象就会被销毁.<code>std::unique_ptr</code>不能被复制, 但可以把它移动给新所有主.<br><code>std::shared_ptr</code>同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制<br>不要使用 std::auto_ptr, 使用 std::unique_ptr 代替它</p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; FooFactory();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FooConsumer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; ptr)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<a href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py" target="_blank" rel="noopener"><code>cpplint.py</code></a>检查风格错误.</p>
</li>
</ol>
<h1 id="其他-C-特性"><a href="#其他-C-特性" class="headerlink" title="其他 C++ 特性"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/" target="_blank" rel="noopener">其他 C++ 特性</a></h1><ol>
<li><p>所有按引用传递的参数必须加上<code>const</code></p>
<blockquote>
<p>在C语言中, 如果函数需要修改变量的值, 参数必须为指针, 如<code>int foo(int *pval)</code>. 在 C++ 中, 函数还可以声明引用参数:<code>int foo(int &amp;val)</code></p>
</blockquote>
</li>
<li><p>只在定义移动构造函数与移动赋值操作时使用右值引用.</p>
</li>
</ol>
<ol>
<li><p>我们不允许使用变长数组和<code>alloca()</code></p>
<blockquote>
<p>改用更安全的分配器（allocator），例如<code>std::vector</code>或<code>std::unique_ptr&lt;T[]&gt;</code></p>
</blockquote>
</li>
<li><p>合理使用友元</p>
<ul>
<li>将<code>FooBuilder</code>声明为<code>Foo</code>的友元</li>
<li>将一个单元测试类声明成待测类的友元</li>
</ul>
</li>
<li><p>禁止使用异常</p>
<blockquote>
<p>这是Google自己的偏好</p>
</blockquote>
</li>
<li><p>禁止使用RTTI</p>
<blockquote>
<p>在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. </p>
</blockquote>
</li>
<li><p>使用C++风格的类型转换方式，如<code>static_cast&lt;&gt;()</code>，不要使用<code>int y = (int)x</code>或<code>int y = int(x)</code>等转换方式</p>
<ul>
<li>用<code>static_cast</code>替代C风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用<code>const_cast</code>去掉<code>const</code>限定符.</li>
<li>用<code>reinterpret_cast</code>指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
</li>
<li><p>不要使用流, 除非是日志接口需要. 使用 printf 之类的代替</p>
</li>
<li><p>对于迭代器和其他模板对象使用前缀形式<code>(++i)</code>的自增, 自减运算符</p>
</li>
<li><p>尽可能地使用<code>const</code>，特别是如下情况</p>
<ul>
<li>函数不会修改传你入的引用或指针类型参数, 该参数应声明为<code>const</code></li>
<li>访问函数应该总是<code>const</code>.其他不会修改任何数据成员, 未调用非<code>const</code>函数, 不会返回数据成员非<code>const</code>指针或引用的函数也应该声明成<code>const</code></li>
<li>数据成员在对象构造之后不再发生变化, 可将其定义为<code>const</code></li>
</ul>
</li>
<li><p>将const放在前面</p>
<blockquote>
<p><code>const int* foo</code>优于<code>int const *foo</code></p>
</blockquote>
</li>
<li><p>用<code>constexpr</code>来定义真正的常量，或实现常量初始化.</p>
<blockquote>
<p>没有说明要将const替换为constexpr，因而只是一个建议</p>
</blockquote>
</li>
<li><p>关于整型，以下必须清楚:</p>
<ul>
<li>C++没有指定整型的大小.通常人们假定short是16位,int是32位,long是32位,long long是 64 位</li>
<li><code>&lt;stdint.h&gt;</code>定义了<code>int16_t</code>,<code>uint32_t</code>,<code>int64_t</code>等整型, 在需要确保整型大小时可以使用它们代替<code>short</code>,<code>unsigned long long</code>等</li>
<li>不要使用<code>uint32_t</code>等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出</li>
</ul>
</li>
<li><p>出于64 位下的可移植性的考量，代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记</p>
</li>
<li><p>谨慎地使用宏，可以的话，尽量用内联函数, 枚举和常量代替之，不得不用时候，切记如下：</p>
<ul>
<li>不要在 .h 文件中定义宏.</li>
<li>在马上要使用时才进行 #define, 使用后要立即 #undef.</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用 ## 处理函数，类和变量的名字。</li>
</ul>
</li>
<li><p>关于零值：</p>
<ul>
<li>整数用0</li>
<li>实数用 0.0</li>
<li>指针C++03项目则用<code>NULL</code>，C++11项目用<code>nullptr</code></li>
<li>字符串用’\0’</li>
</ul>
</li>
<li><p>尽可能用<code>sizeof(varname)</code>代替<code>sizeof(type)</code>以防止varname的type变化的情况</p>
</li>
<li><p>只在局部变量中使用auto简化书写</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> s1 = v[<span class="number">0</span>];  <span class="comment">// 创建一份 v[0] 的拷贝。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; s2 = v[<span class="number">0</span>];  <span class="comment">// s2 是 v[0] 的一个引用。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>善用列表初始化</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector 接收了一个初始化列表。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不考虑细节上的微妙差别，大致上相同。</span></span><br><span class="line"><span class="comment">// 您可以任选其一。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以配合 new 一起用。</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 接收了一些 pair, 列表初始化大显神威。</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"2"</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表也可以用在返回类型上的隐式转换。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test_function() &#123; <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表可迭代。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>&#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数调用里用列表初始化。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunction2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">TestFunction2(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
</li>
<li><p>少用模板，模板维护成本高，只适合在大量使用的基础组件或数据结构上</p>
</li>
</ol>
<h1 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/" target="_blank" rel="noopener">命名约定</a></h1><ol>
<li><p>函数、变量、文件名要有描述性，少用缩写，除非那些被广泛认可的。</p>
</li>
<li><p>文件名</p>
<ul>
<li>全部小写</li>
<li>通过<code>_</code>连接</li>
<li>要以<code>.cc</code>或者<code>.h</code>结尾，且成对出现</li>
</ul>
</li>
<li><p>类型名</p>
<ul>
<li>首字母大写</li>
<li>不包含下划线</li>
</ul>
</li>
<li><p>变量名</p>
<ul>
<li>全部小写，用下划线连接</li>
<li>类成员变量以下划线结尾，结构体不用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> table_name;  <span class="comment">// 好 - 用下划线.</span></span><br><span class="line"><span class="built_in">string</span> tablename;   <span class="comment">// 好 - 全小写.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tableName;  <span class="comment">// 差 - 混合大小写</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableInfo</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span> table_name_;  <span class="comment">// 好 - 后加下划线.</span></span><br><span class="line">  <span class="built_in">string</span> tablename_;   <span class="comment">// 好.</span></span><br><span class="line">  <span class="keyword">static</span> Pool&lt;TableInfo&gt;* pool_;  <span class="comment">// 好.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>常量名</p>
<ul>
<li>声明为<code>constexpr</code>或<code>const</code>的变量，命名时以“k”结尾<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDaysInAWeek = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>函数命名</p>
<ul>
<li>首字母大写</li>
<li>驼峰式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AddTableEntry()</span><br><span class="line">DeleteUrl()</span><br><span class="line">OpenFileOrDie()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>命名空间名</p>
<ul>
<li>全小写命名</li>
<li>应对应一个可以存放其代码的文件夹</li>
</ul>
</li>
<li><p>枚举名</p>
<ul>
<li>优先采用常量命名方法，其次宏名可接受<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> UrlTableErrors &#123;</span><br><span class="line">    kOK = <span class="number">0</span>,</span><br><span class="line">    kErrorOutOfMemory,</span><br><span class="line">    kErrorMalformedInput,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> AlternateUrlTableErrors &#123;</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    OUT_OF_MEMORY = <span class="number">1</span>,</span><br><span class="line">    MALFORMED_INPUT = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>宏</p>
<ul>
<li>全部大写，下划线连接<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_ROUNDED 3.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/comments" target="_blank" rel="noopener">注释</a></h1><ol>
<li><p>风格</p>
<ul>
<li>使用<code>//</code>或<code>/* */</code>, 统一就好</li>
</ul>
</li>
<li><p>文件注释</p>
<ul>
<li>加入版权公告</li>
<li>述了该文件的内容</li>
</ul>
</li>
<li><p>类注释</p>
<ul>
<li>每个类的定义都要附带一份注释, 描述类的功能和用法</li>
<li>描述类用法的注释应当和接口定义<code>(.h)</code>放在一起, 描述类的操作和实现的注释应当和实现<code>(.cc)</code>放在一起.</li>
</ul>
</li>
<li><p>函数注释</p>
<ul>
<li>函数声明处的注释描述函数功能</li>
<li>定义处的注释描述函数实现</li>
<li>注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”)</li>
<li>注释重载函数时，重点应该是函数中被重载的部分</li>
<li>注释构造函数时，重点在对参数做了什么</li>
<li>注释析构函数时，重点在清理了什么内容，没有的话，可以不注释<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns an iterator for this table.  It is the client's</span></span><br><span class="line"><span class="comment">// responsibility to delete the iterator when it is done with it,</span></span><br><span class="line"><span class="comment">// and it must not use the iterator once the GargantuanTable object</span></span><br><span class="line"><span class="comment">// on which the iterator was created has been deleted.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The iterator is initially positioned at the beginning of the table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This method is equivalent to:</span></span><br><span class="line"><span class="comment">//    Iterator* iter = table-&gt;NewIterator();</span></span><br><span class="line"><span class="comment">//    iter-&gt;Seek("");</span></span><br><span class="line"><span class="comment">//    return iter;</span></span><br><span class="line"><span class="comment">// If you are going to immediately seek to another place in the</span></span><br><span class="line"><span class="comment">// returned iterator, it will be faster to use NewIterator()</span></span><br><span class="line"><span class="comment">// and avoid the extra seek.</span></span><br><span class="line"><span class="function">Iterator* <span class="title">GetIterator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变量注释</p>
<ul>
<li>如果变量名足以说明用途，则不必再注释了</li>
<li><p>如果变量可以接受<code>NULL</code>或<code>-1</code>等警戒值, 须加以说明</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// Used to bounds-check table accesses. -1 means</span></span><br><span class="line"> <span class="comment">// that we don't yet know how many entries the table has.</span></span><br><span class="line"> <span class="keyword">int</span> num_total_entries_;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The total number of tests cases that we run through in this regression test.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumTestCases = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实现注释</p>
<ul>
<li>巧妙或复杂的代码段<strong>前</strong>要加注释</li>
<li>比较隐晦的地方要在行尾加入注释，行尾注释空两格，如果多行注释一起，可以使之对齐</li>
<li>如果函数有多个配置项，可以定义一个类来保存所有的选项</li>
<li>对于代码水平比你高的人还看不懂你的用意的，要加注释</li>
</ul>
</li>
<li><p>TODO注释</p>
<ul>
<li>对于临时的、不完美的方案要用TODO</li>
<li>之后用括号加上名字或者bug号码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span></span><br><span class="line"><span class="comment">// TODO(Zeke) change this to use relations.</span></span><br><span class="line"><span class="comment">// TODO(bug 12345): remove the "Last visitors" feature</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>弃用注释</p>
<ul>
<li>通过弃用注释（DEPRECATED comments）以标记某接口点已弃用</li>
</ul>
</li>
<li><p>关于标点, 拼写和语法</p>
<ul>
<li>包含正确的大小写</li>
<li>包含完整结尾句号</li>
</ul>
</li>
</ol>
<h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/" target="_blank" rel="noopener">格式</a></h1><ol>
<li><p>行长度</p>
<ul>
<li>最多80个字符</li>
</ul>
</li>
<li><p>非ASCII字符</p>
<ul>
<li>尽量不适用非ASCII字符，使用时必须使用UTF-8编码，单元测试不受此限制</li>
</ul>
</li>
<li><p>缩进</p>
<ul>
<li>只用空格，每次2个</li>
</ul>
</li>
<li><p>函数声明与定义</p>
<ul>
<li><p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,</span><br><span class="line">                                             Type par_name3) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReturnType LongClassName::ReallyReallyReallyLongFunctionName(</span><br><span class="line">    Type par_name1,  <span class="comment">// 4 space indent</span></span><br><span class="line">    Type par_name2,</span><br><span class="line">    Type par_name3) &#123;</span><br><span class="line">  DoSomething();  <span class="comment">// 2 space indent</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回类型和函数名在一行放不下, 分行，不要缩进</p>
</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行</li>
<li>换行后保持4空格缩进</li>
<li>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Circle::Rotate(<span class="keyword">double</span> <span class="comment">/*radians*/</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Lambda</p>
<ul>
<li>Lambda表达式对形参和函数体的格式化和其他函数一致</li>
</ul>
</li>
<li><p>函数调用</p>
<ul>
<li>要么一行写完函数调用，要么圆括号里参数分行，要么另起一行缩进4格<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一行写完函数调用</span></span><br><span class="line"><span class="keyword">bool</span> retval = DoSomething(argument1, argument2, argument3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆括号里参数分行</span></span><br><span class="line"><span class="keyword">bool</span> retval = DoSomething(averyveryveryverylongargument1,</span><br><span class="line">                          argument2, argument3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另起一行缩进4格</span></span><br><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    DoSomething(</span><br><span class="line">        argument1, argument2,  <span class="comment">// 4 空格缩进</span></span><br><span class="line">        argument3, argument4);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>列表初始化格式</p>
<ul>
<li>与函数调用初始化同理<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一行列表初始化示范.</span></span><br><span class="line"><span class="keyword">return</span> &#123;foo, bar&#125;;</span><br><span class="line">functioncall(&#123;foo, bar&#125;);</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p&#123;foo, bar&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不得不断行时.</span></span><br><span class="line">SomeFunction(</span><br><span class="line">    &#123;<span class="string">"assume a zero-length name before &#123;"</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    some_other_function_parameter);</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    some, other, values,</span><br><span class="line">    &#123;<span class="string">"assume a zero-length name before &#123;"</span>&#125;,  <span class="comment">// 假设在 &#123; 前有长度为零的名字.</span></span><br><span class="line">    SomeOtherType&#123;</span><br><span class="line">        <span class="string">"Very long string requiring the surrounding breaks."</span>,  <span class="comment">// 非常长的字符串, 前后都需要断行.</span></span><br><span class="line">        some, other values&#125;,</span><br><span class="line">    SomeOtherType&#123;<span class="string">"Slightly shorter string"</span>,  <span class="comment">// 稍短的字符串.</span></span><br><span class="line">                  some, other, values&#125;&#125;;</span><br><span class="line">SomeType variable&#123;</span><br><span class="line">    <span class="string">"This is too long to fit all in one line"</span>&#125;;  <span class="comment">// 字符串过长, 因此无法放在同一行.</span></span><br><span class="line">MyType m = &#123;  <span class="comment">// 注意了, 您可以在 &#123; 前断行.</span></span><br><span class="line">    superlongvariablename1,</span><br><span class="line">    superlongvariablename2,</span><br><span class="line">    &#123;<span class="keyword">short</span>, interior, <span class="built_in">list</span>&#125;,</span><br><span class="line">    &#123;interiorwrappinglist,</span><br><span class="line">     interiorwrappinglist2&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>条件语句</p>
<ul>
<li>不在圆括号里使用空格</li>
<li><p><code>if</code>跟<code>else</code>另起一行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;  <span class="comment">// 圆括号里没有空格.</span></span><br><span class="line">  ...  <span class="comment">// 2 空格缩进.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;  <span class="comment">// else 与 if 的右括号同一行.</span></span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简短的条件语句允许写在同一行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == kBar) <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br></pre></td></tr></table></figure>
</li>
<li><p>单行语句可以使用大括号，不过推荐使用大括号</p>
</li>
</ul>
</li>
<li><p>循环和开关选择语句</p>
<ul>
<li><p>包含default值，如果<code>default</code>应该永远执行不到, 简单的加条<code>assert</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (var) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;  <span class="comment">// 2 空格缩进</span></span><br><span class="line">    ...      <span class="comment">// 4 空格缩进</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在单语句循环里, 括号可用可不用</p>
</li>
<li>空循环体应使用<code>{}</code>或<code>continue</code>, 而不是一个简单的分号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kSomeNumber; ++i) &#123;&#125;  <span class="comment">// 可 - 空循环体.</span></span><br><span class="line"><span class="keyword">while</span> (condition) <span class="keyword">continue</span>;  <span class="comment">// 可 - contunue 表明没有逻辑.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>指针和引用表达式</p>
<ul>
<li>句点或箭头前后不要有空格. 指针/地址操作符 (*, &amp;) 之后不能有空格</li>
<li>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好, 空格前置.</span></span><br><span class="line"><span class="keyword">char</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> &amp;str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好, 空格后置.</span></span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span>&amp; str;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>布尔表达式</p>
<ul>
<li>超过行宽，需要断行，断行时候<code>&amp;&amp;</code>等要放在末尾</li>
</ul>
</li>
<li><p>变量及数组初始化</p>
<ul>
<li>用 =, () 和 {} 均可<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"Some Name"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">"Some Name"</span>;</span><br><span class="line"><span class="built_in">string</span> name&#123;<span class="string">"Some Name"</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>预处理指令</p>
<ul>
<li>不要缩进，即使在缩进代码中<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (lopsided_score) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISASTER_PENDING      <span class="comment">// 正确 - 从行首开始</span></span></span><br><span class="line">    DropEverything();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> NOTIFY               <span class="comment">// 非必要 - # 后跟空格</span></span></span><br><span class="line">    NotifyClient();</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    BackToNormal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类格式</p>
<ul>
<li>访问控制块的声明依次序是 public:, protected:, private:，每次一个缩进</li>
<li>public:等关键词控制块之间要空一行，关键词之后不要空行<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> :</span> <span class="keyword">public</span> OtherClass &#123;</span><br><span class="line"> <span class="keyword">public</span>:      <span class="comment">// 注意有一个空格的缩进</span></span><br><span class="line">  MyClass();  <span class="comment">// 标准的两空格缩进</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> var)</span></span>;</span><br><span class="line">  ~MyClass() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SomeFunctionThatDoesNothing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_some_var</span><span class="params">(<span class="keyword">int</span> var)</span> </span>&#123; some_var_ = var; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">some_var</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> some_var_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SomeInternalFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> some_var_;</span><br><span class="line">  <span class="keyword">int</span> some_other_var_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>构造函数初始值列表</p>
<ul>
<li>构造函数初始化列表放在同一行或按四格缩进并排多行<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果所有变量能放在同一行:</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var) : some_var_(var) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不能放在同一行,</span></span><br><span class="line"><span class="comment">// 必须置于冒号后, 并缩进 4 个空格</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var), some_other_var_(var + <span class="number">1</span>) &#123;</span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span></span><br><span class="line"><span class="comment">// 并逐行对齐</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var),             <span class="comment">// 4 space indent</span></span><br><span class="line">      some_other_var_(var + <span class="number">1</span>) &#123;  <span class="comment">// lined up</span></span><br><span class="line">  DoSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右大括号 &#125; 可以和左大括号 &#123; 放在同一行</span></span><br><span class="line"><span class="comment">// 如果这样做合适的话</span></span><br><span class="line">MyClass::MyClass(<span class="keyword">int</span> var)</span><br><span class="line">    : some_var_(var) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>命名空间</p>
<ul>
<li>不缩进，嵌套也不缩进<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> foo &#123;</span><br><span class="line"><span class="keyword">namespace</span> bar &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>水平留白</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;  <span class="comment">// 左大括号前总是有空格.</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  <span class="comment">// 分号前不加空格.</span></span><br><span class="line"><span class="comment">// 列表初始化中大括号内的空格是可选的.</span></span><br><span class="line"><span class="comment">// 如果加了空格, 那么两边都要加上.</span></span><br><span class="line"><span class="keyword">int</span> x[] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> x[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承与初始化列表中的冒号前后恒有空格.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> :</span> <span class="keyword">public</span> Bar &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 对于单行函数的实现, 在大括号内加上空格</span></span><br><span class="line">  <span class="comment">// 然后是函数实现</span></span><br><span class="line">  Foo(<span class="keyword">int</span> b) : Bar(), baz_(b) &#123;&#125;  <span class="comment">// 大括号里面是空的话, 不加空格.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; baz_ = <span class="number">0</span>; &#125;  <span class="comment">// 用空格把大括号与实现分开.</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b) &#123;          <span class="comment">// if 条件语句和循环语句关键字后均有空格.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;          <span class="comment">// else 前后有空格.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (test) &#123;&#125;   <span class="comment">// 圆括号内部不紧邻空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> ( ; i &lt; <span class="number">5</span> ; ++i) &#123;  <span class="comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span></span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:         <span class="comment">// switch case 的冒号前无空格.</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>;  <span class="comment">// 如果冒号有代码, 加个空格.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值运算符前后总是有空格.</span></span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span></span><br><span class="line"><span class="comment">// 圆括号内部没有紧邻空格.</span></span><br><span class="line">v = w * x + y / z;</span><br><span class="line">v = w*x + y/z;</span><br><span class="line">v = w * (x + z);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在参数和一元操作符之间不加空格.</span></span><br><span class="line">x = <span class="number">-5</span>;</span><br><span class="line">++x;</span><br><span class="line"><span class="keyword">if</span> (x &amp;&amp; !y)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; x;</span><br><span class="line">y = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span> *&gt; x;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/26/Reed–Solomon-codes-for-coders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lylex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lylex's humble Home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/26/Reed–Solomon-codes-for-coders/" itemprop="url">
                  [译]为程序员而作的Reed–Solomon编码详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-26 01:25:17" itemprop="dateCreated datePublished" datetime="2018-06-26T01:25:17-06:00">2018-06-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-12-26 03:27:41" itemprop="dateModified" datetime="2018-12-26T03:27:41-07:00">2018-12-26</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="译-为程序员而作的Reed–Solomon编码详解"><a href="#译-为程序员而作的Reed–Solomon编码详解" class="headerlink" title="[译]为程序员而作的Reed–Solomon编码详解"></a>[译]为程序员而作的Reed–Solomon编码详解</h2><p><strong>原文：<a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders" target="_blank" rel="noopener">Reed–Solomon codes for coders</a> 作者：Unknown</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Error_detection_and_correction" target="_blank" rel="noopener">纠错码</a>是一个用于纠正错误的处理技巧。他们现在是无所不在，例如，在通讯中（移动电话、互联网），数据存储和归档（硬盘、CD/DVD/BluRay光盘）,仓储管理（条形码）以及广告（QR码）。</p>
<p><a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction" target="_blank" rel="noopener">Reed–Solomon纠错码</a>是一种典型的纠错码。它是一种古老但又被广泛使用的编码，因为它被定义地很好并且它的好些高效的算法实现在公共领域中可以使用了。</p>
<p>通常的，纠错码是隐藏的并且大多数用户甚至都不知道它们，也不知道他们何时被使用了。他们是很多应用赖以维继的不可或缺的组件，比如通讯和数据存储。确实，一个每几天都会随即丢失数据的硬盘是没有什么用的，通用一个只能在万里无云的天气才能使用的电话也是没有用的。通过使用纠错码，可以将被干扰的信息恢复成完整的原始信息。</p>
<p>条形码和二维码是学起来比较有意思的东西，因为它们有着将纠错码可视化从而将这些编码让好奇的用户可以触及的一种特异功能。</p>
<p>在这篇文章中，我们将尝试从一个程序员而不是数学家的视角来阐述Reed–Solomon的原理，也就是说，我们将侧重实践多于理论，尽管我们也会讲讲理论，但那只是为了直观和实现的必要知识。这个领域中著名的参考文献也将会被提供出来，这样感兴趣的读者也能在数学理论中挖地更深点。<br>我们也将提供现实世界中采集的关于QR码系统和可以用的编码范例。我们将采用Python来讲这些范例（主要因为它看起来简单并且接近伪代码），但是我们也将为不熟悉这个语言的人来阐述一些不明显的关于这个语言的特性。这里涉及到的数学知识通常被认为大学以下是没怎么教过的，但是高中代数知识学得好的人也能掌握。</p>
<p>我们先浅显地介绍纠错码之后的编码知识，然后再第二部分我们来介绍QR码（译者注：即二维码，以下不再区分）的结构化的介绍，换句话说就是信息是怎么存储在QR码中以及怎样读取、制作它的，然后在第三部分我们将通过Reed–Solomon解码器的实现来学习纠错码，通过更高一点的BCH编码家族的快速介绍，从而可以可靠地读取QR码。</p>
<p>提醒好奇的读者的是，扩展信息可以在讨论页的附录中可以看到。</p>
<h1 id="纠错原理"><a href="#纠错原理" class="headerlink" title="纠错原理"></a>纠错原理</h1><p>在细说编码之前，理解下纠错背后的直观只是可能是有用的。事实上，尽管纠错码可能看起来有着高深莫测的数学理论，但是绝大多数数学操作是高中级别的（Galois域是个例外，但是它事实上这对于程序员来说是很容易很普遍的：它就是简单地在实数取模上做了一些操作。）<br>然而，纠错码背后的数学精巧的复杂性隐藏了这个实践中的直观的目标和机制。</p>
<p>纠错码可能看起来像是一个比较难的数学概念，但他们事实上是基于一个直观的想法加上一个精巧的数学实现：<strong>让我们把数据结构化，通过某种方法我们能猜到一个被损毁的数据是什么，仅仅依靠“修理”这个结构</strong>。数学上，我们采用来自于Galois域的多项式来实现这个结构。</p>
<p>让我们来作一个实际的类比：比如说我们想要交流信息给别人，但是这些信息可能在路上被损毁。纠错码的主要洞察力是，<strong>与其使用一整个字典的单词，我们可以使用一组精选过的单词，一个“精简过的字典”，这样每个单词都和其他的单词不一样了</strong>。这样，当我们收到一个消息的时候，我们仅仅需要在我们这个精简过的字典中查询了，从而可以<strong>1）检测</strong>哪个词被损坏了（因为他们不在我们的精简字典中）；<strong>2）修正</strong>被损坏的词，通过在这个字典中最相近的词来实现。</p>
<p>让我们来举一个简单的例子：我们有一个精简的带有仅仅三个含有四个字母的字典：this、that和corn。比如说，我们接受到了一个被损坏的词：co**，其中*表示被擦除了。既然我们仅仅有3个词在我们的字典中，我们就能非常容易地比较接收到的词和我们字典中的词，从而来找到哪个是最接近的单词。在这个例子中，是corn。那么丢失的字母是rn。</p>
<p>现在我们假设接受到了单词th**。问题就变成在我们的字典中有两个词跟这个接收到的词相匹配：this和that。这种情况下，我们不能确定它是哪个，因而不能解码。这意味着我们的字典不是那么的好，因而我们应当用其他更复杂的单词来代替that，例如dash，来最大化每个单词之间的区别。这个区别，或者更确切地说是我字典中任意两个单词之间不同字母的最小数目，叫做我们字典的<strong>最大海明距离</strong>。记住，字典中任意2个单词在同一位置共享的最小字母数个数叫做“最大可分离性”。</p>
<p>同样的原则也被应用在了纠错码上：我们只是生产一个简化的只包含最大可分离性的单词的简化字典（我们也会在第三部分深入讨论如何做），并且我们也会用这个简化字典中的单词进行通讯。Galois域所提供的是这个结构（也就是，简化字典的基础），而Reed-Solomon是一个自动构建这个合适的结构的方法（制作一个为一个数据集量身定制的具备最大可分离性的简化字典），也提供一个自动的方法来检测和纠正错误（也就是在简化自动中查找）。更精确点说，Galois域就是这个结构（多亏了它们的循环的特质，对实数的取模），而Reed-Solomon就是这个基于Galois域的编解码方法。</p>
<p>如果一个单词在通讯中被损坏了，那也没什么大不了的，因为我们可以通过查找字典并找到最接近的单词，从而很容易地修正它，这大概就是正确的（然而我们也可能选一个错误的词，如果这个输入信息被高度损坏了的话，但是这个可能性是非常的小的）。同样的，我们的单词越长，他们的分离性越强，因为更多字母会在没有任何影响的情况下被损坏。</p>
<p>制作一个带有最大可分离性的字典的最简单的方法就是去让单词变得比它们实际上更长。</p>
<p>让我们在来看看我们的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t h i s</span><br><span class="line">t h a t</span><br><span class="line">c o r n</span><br></pre></td></tr></table></figure>
<p>增加一组各不相同的字母，这样在任何增加的位置就没有重复的字母了，并增加一个额外的单词来帮助解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t h i s a b c d</span><br><span class="line">t h a t b c d e</span><br><span class="line">c o r n c d e f</span><br><span class="line">t h i n d e f g</span><br></pre></td></tr></table></figure>
<p>注意，最少通过5个字母，就可以把这个字典中每一个词跟其他词区分出来，因此距离是5。这个可以容忍在已知位置的四个错误，也被叫做消磁，或者2个在位置位置等待被纠正的错误。</p>
<p>假设4个消磁出现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t * * * a b * d</span><br></pre></td></tr></table></figure>
<p>那么在这个字典中找着四个没有被消磁的字母就可以找到那个跟这四个字母相匹配的单词，因为距离是5。</p>
<p>假设这2个错误就是一下这些形式中的一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t h i x a x c d</span><br><span class="line">x h i x a b c d</span><br><span class="line">t h x x a b c d</span><br></pre></td></tr></table></figure>
<p>这里的问题是错误的位置是未知的。8个字母中取6个有28个可能的子集，那么就要做一个6个字母组成的28个子集的查找，然后就同样只有一个子集和这6个字母相匹配，因为距离是5（并且假设小于等于2个错误出现）。</p>
<p>通过这个例子，我们可以看到冗余在恢复丢失的信息中的优势：冗余字符可以帮助你恢复你的原始数据。以上的例子展示了一个粗糙的纠错是如何工作的。Reed-Solomon的核心思想是相近的，根据Galois域理论在一个信息中附加冗余数据。原始的纠错解码器和上面的找错误的例子接近，搜索接受到的信息与有效信息相对应的子集，然后选择最接近的作为纠正后的信息。这个对于较大的信息是不可实现的，因此数学理论被开发出来从而可以在合理的时间里实行错误纠正。</p>
<h1 id="QR码结构"><a href="#QR码结构" class="headerlink" title="QR码结构"></a>QR码结构</h1><p>这节介绍QR码的结构，也就是数据是如何存储在QR码中的。本节信息是不完整的，那是有意为之的。这里只介绍了小的21*21大小的符号（就是大家熟知的版本1）最基本的功能，想要知道额外的信息看附录吧。</p>
<p>这里一个QR符号将被用来作为例子。它由黑白方块组成，在条码世界中被叫做模块。三个在角落的方块定位模式是QR码鲜明的特征。</p>
<p><img src="/2018/06/26/Reed–Solomon-codes-for-coders/QR_Code_Example.png" width="250" height="250" alt="QR_Code_Example"></p>
<h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p>掩码过程是用来规避图像数据中那些迷惑扫描器的特性，譬如那些看起来像定位器模式的具有误导性的形状和大片的空白区域。掩码反转了某些模块（使得白的变黑的，黑的变白的），而其他的保持不变。</p>
<p>在下图中，红色区域编码了格式信息并使用了一个固定的掩码模式。数据区域（黑色和白色的部分）用可变的模式作了掩码计算。生成编码的时候，编码器尝试了若干不同的掩码，并选择了能够最小化结果中不良特征的那一个掩码。选择的掩码模式被表示在了格式信息中，因而解码器就知道用哪个掩码模式了。浅灰色区域是固定的模式，它们并没有编码任何信息。除了明显的定位模式之外，还有其他的包含黑白模块交错的标尺模式。</p>
<p><img src="/2018/06/26/Reed–Solomon-codes-for-coders/QR_Code_Masking_Example.png" width="600" height="2000" alt="QR_Code_Example"></p>
<p>掩码转换很容易通过异或运算（在很多编程语言中用^来表示）来施加（或去除）。格式信息的反掩码如下所示。逆时针读取左上角的定位模式，我们得到如下的比特序列。其中白色模块表示0，黑色的表示1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input       101101101001011</span><br><span class="line">Mask      ^ 101010000010010</span><br><span class="line">Output      000111101011001</span><br></pre></td></tr></table></figure>
<h2 id="格式信息"><a href="#格式信息" class="headerlink" title="格式信息"></a>格式信息</h2><p>格式信息有两个相同的副本，因此即使被损坏了任然能够被解码。第二个副本被分裂成两片，放置在了另外的两个定位器周围，也是通过逆时针方向读取（从左下角向上，然后右上角从左往右）。<br>格式信息的开始的两个比特给出了信息数据的纠错等级。这个大小的二维码包含了26字节的信息。这些信息中的一部分是用来存储信息，一部分是用来纠错的，正如下表所示的。左列仅仅是那个等级的名字。</p>
<table>
<thead>
<tr>
<th style="text-align:center">纠错等级</th>
<th style="text-align:center">等级指示</th>
<th style="text-align:center">纠错字节</th>
<th style="text-align:center">信息数据字节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">01</td>
<td style="text-align:center">7</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">00</td>
<td style="text-align:center">10</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td style="text-align:center">Q</td>
<td style="text-align:center">11</td>
<td style="text-align:center">13</td>
<td style="text-align:center">13</td>
</tr>
<tr>
<td style="text-align:center">H</td>
<td style="text-align:center">10</td>
<td style="text-align:center">17</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<p>格式信息接下来的三个比特数据指定了用于数据区域的掩码模式。这些模式如下所示，包括表明一个模块是不是黑色的数学公式（i和j是分别表示行号和列号，在左上角从0开始编号）。</p>
<p><img src="/2018/06/26/Reed–Solomon-codes-for-coders/QR_Code_Mask_Patterns.png" width="600" height="2000" alt="QR_Code_Mask_Patterns"></p>
<p>剩下的格式信息的十个比特是留个格式信息自己纠错的。这个将会在接下来的章节中解释。</p>
<h2 id="信息数据"><a href="#信息数据" class="headerlink" title="信息数据"></a>信息数据</h2><p>这里有一张大图来展示没有被掩码过的QR码。QR码的不同区域都标记出来了，包括信息数据字节的边界。</p>
<p><img src="/2018/06/26/Reed–Solomon-codes-for-coders/QR_Code_Unmasked.png" width="900" height="900" alt="QR_Code_Unmasked"></p>
<p>数据字节是从右下角开始读取，并沿着右边两列走锯齿形模式。开始的三个字节是01000000 11010010 01110101。接下来的两列是沿着向下方向读取的，因此接下来的字节是01000111。直到读到底了，再向上读两列。就像这样上上下下地处理，直到读到二维码的最左边（有必要的话，跳过标尺模式）。这是十六进制的完整信息。</p>
<pre><code>信息数据字节：40 d2 75 47 76 17 32 06 27 26 96 c6 c6 96 70 ec
错误纠正字节：bc 2a 90 13 6b af ef fd 4b e0
</code></pre><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>最后一步是把信息字节解码成可读的东西。开始的四个比特指明了信息是怎么编码的。QR码采用了好几种编码方案，因此不同的信息都可以被高效地储存。这些被总结在了下表中。模式指示符后是长度字段，表明存了多少字母的。长度字段的大小由特定的编码方式决定。</p>
<table>
<thead>
<tr>
<th style="text-align:center">模式名词</th>
<th style="text-align:center">模式指示符</th>
<th style="text-align:center">长度比特</th>
<th style="text-align:center">数据比特</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数字</td>
<td style="text-align:center">0001</td>
<td style="text-align:center">10</td>
<td style="text-align:center">每三个数字10个比特</td>
</tr>
<tr>
<td style="text-align:center">字母</td>
<td style="text-align:center">0010</td>
<td style="text-align:center">9</td>
<td style="text-align:center">每两个字母11个比特</td>
</tr>
<tr>
<td style="text-align:center">字节</td>
<td style="text-align:center">0100</td>
<td style="text-align:center">8</td>
<td style="text-align:center">每个字符8个比特</td>
</tr>
<tr>
<td style="text-align:center">汉字</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">8</td>
<td style="text-align:center">每个字符13个比特</td>
</tr>
</tbody>
</table>
<p>（上图中长度字段的大小仅仅对小的二维码有效。）</p>
<p>我们的范例信息开始于0100，表示每个字符有8个比特。接下来的8比特是长度字段，00001101，或者是十进制的13。之后的就是实际的信息字符了。开始的两个是00100111和01010100（ASCII编码中的省略号和T）。有兴趣的读者可以自行解码剩下的信息。</p>
<p>数据比特之后是另外的4比特的模式指示符。它可以跟第一个不同，可以容许不同的编码和QR码混合其中。当没有更多数据要存的时候，就给个0000来作为特殊的信息结束标志。（注意，标准允许信息结束码可以被省略，如果可用的数据字节数不够的话。）</p>
<p>从这点上来讲，我们知道了如何去解码或者去读取一个完整二维码。然后，在真实的情况下，一个二维码很少是完整的：通常，它是通过手机摄像头来扫描的，可能是在光照条件不好的情况下照的，或者表面有划痕导致部分二维码被抠掉了，或者在一个被涂掉了的表面，等等。</p>
<p>为了让我们的二维码解码器更加<strong>可靠</strong>，我们需要能够<strong>纠正</strong>错误。这篇文章接下来的这部分就会描述如何去纠正错误，通过构建一个BCH解码器，以及更加专门的Reed-Solomon解码器。</p>
<h1 id="BCH编码"><a href="#BCH编码" class="headerlink" title="BCH编码"></a>BCH编码</h1><p>在这节中，我们来介绍一个大众级别的纠错码：BCH编码，是现代Reed-Solomon编码的父母辈的，也是基础的检测和纠正机制。</p>
<p>格式信息是用BCH码来编码的，它使得一定数目的比特错误能够被检测并纠正。BCH码是一种通用版的Reed-Solomon编码（现代Reed-Solomon编码属于BCH编码的一种）。在二维码的例子中，用于格式信息的BCH编码要比用于信息数据的Reed-Solomon编码来简单一些，因此从用于格式信息的BCH编码开始是合理的。</p>
<h2 id="BCH错误检测"><a href="#BCH错误检测" class="headerlink" title="BCH错误检测"></a>BCH错误检测</h2><p>检查编码信息的过程类似于长除，只是使用异或而非减法。格式编码被所谓的编码构建者（generator）“除”的时候应当产生余数0。QR格式编码采用的构建者是10100110111。我们例子中的格式信息编码（000111101011001）的处理过程如下所示。</p>
<p><img src="/2018/06/26/Reed–Solomon-codes-for-coders/divide.png" width="300" height="300" alt="divide"></p>
<p>这里用Python函数来实现这个计算过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qr_check_format</span><span class="params">(fmt)</span>:</span></span><br><span class="line">   g = <span class="number">0x537</span> <span class="comment"># = 0b10100110111 in python 2.6+</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">      <span class="keyword">if</span> fmt &amp; (<span class="number">1</span> &lt;&lt; (i+<span class="number">10</span>)):</span><br><span class="line">         fmt ^= g &lt;&lt; i</span><br><span class="line">   <span class="keyword">return</span> fmt</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">qr_check_format</span><span class="params">(fmt <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> g <span class="keyword">uint</span> = <span class="number">0x537</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">4</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">                <span class="keyword">if</span> fmt&amp;(<span class="number">1</span>&lt;&lt;(<span class="keyword">uint</span>)(i+<span class="number">10</span>)) != <span class="number">0</span> &#123;</span><br><span class="line">                        fmt ^= g &lt;&lt; <span class="keyword">uint</span>(i)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fmt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Python注解</em>：range函数可能对于非Python程序员不怎么清楚。它制造一个一系列数字从4数到0。在C系的语言中，用for循环可以写成<code>for (i = 4; i &gt;= 0; i--)</code>；在Pascal系语言中是<code>for i := 4 downto 0.</code>.</p>
<p><em>Python注解2</em>：&amp;操作符表示按位与，&lt;&lt;表示向左移位。这个和C系语言是一致的。</p>
<p>(译者注：笔者熟悉Golang胜过Python，为了自己阅读方便，故而偶遇难读之Python，也会用Golang重写之，下同)</p>
<p>这个函数也一个被用来编码5比特的格式信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encoded_format = (format&lt;&lt;<span class="number">10</span>) ^ qr_check_format(format&lt;&lt;<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>读者可能会将这个函数推广到可以除以不同的数字视为一种有趣的练习。例如，大的二维码包含了6比特的版本信息和12比特错误纠正信息，并使用1111100100101作为构造者。</p>
<p>在数学意义上，这些二进制数被描述成整数模2作为系数的多项式。这个数字的每一个比特都对应一个系数。例如：<br>10100110111 = 1 x^10 + 0 x^9 + 1 x^8 + 0 x^7 + 0 x^6 + 1 x^5 + 1 x^4 + 0 x^3 + 1 x^2 + 1 x + 1 = x^10 + x^8 + x^5 + x^4 + x^2 + x + 1</p>
<p>如果qr_check_format产生的余数不为0，那么这个编码就已经被损坏或者误读了。接下来就要检测本来打算用的格式编码最像哪个了（也就是查找我们的冗余字典了）。</p>
<h2 id="BCH纠错"><a href="#BCH纠错" class="headerlink" title="BCH纠错"></a>BCH纠错</h2><p>尽管用于解码BCH编码的复杂算法存在了，但是在我们的例子也未免有点杀鸡用牛刀了。因为仅仅有32种可能的格式编码，所以一个一个地去尝试然后挑选一个和问题中的编码比特位差异位数最小的一个反而容易点（比特位差异数就是Hamming距离）。寻找最近的编码的方法叫做穷举搜索，并且是可行的因为我们有很少的编码要去尝试（一个编码是一个有效的信息，并且这里只有32个，所有其他的二进制数都是不正确的）。</p>
<p>（注意，Reed–Solomon算法也是基于这样的一个原则，但是由于可能的编码码文种类太多了，我们没法去穷举搜索，这就是为什么聪明但复杂的算法被发明出来的原因吧，比如Berlekamp-Massey）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hamming_weight</span><span class="params">(x)</span>:</span></span><br><span class="line">   weight = <span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">      weight += x &amp; <span class="number">1</span></span><br><span class="line">      x &gt;&gt;= <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> weight</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qr_decode_format</span><span class="params">(fmt)</span>:</span></span><br><span class="line">   best_fmt = <span class="number">-1</span></span><br><span class="line">   best_dist = <span class="number">15</span></span><br><span class="line">   <span class="keyword">for</span> test_fmt <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">32</span>):</span><br><span class="line">      test_code = (test_fmt&lt;&lt;<span class="number">10</span>) ^ qr_check_format(test_fmt&lt;&lt;<span class="number">10</span>)</span><br><span class="line">      test_dist = hamming_weight(fmt ^ test_code)</span><br><span class="line">      <span class="keyword">if</span> test_dist &lt; best_dist:</span><br><span class="line">         best_dist = test_dist</span><br><span class="line">         best_fmt = test_fmt</span><br><span class="line">      <span class="keyword">elif</span> test_dist == best_dist:</span><br><span class="line">         best_fmt = <span class="number">-1</span></span><br><span class="line">   <span class="keyword">return</span> best_fmt</span><br></pre></td></tr></table></figure>
<p>如果格式编码不能够被毫无歧义地解码，那么qr_decode_format函数返回-1。这个情况发生于两个或多个格式编码与输入有着同样的距离。</p>
<p>要在Python中跑这段代码，首先启动IDLE，也就是Python的集成开发环境。你应该看到一个版本信息和交互式输入提示符&gt;&gt;&gt;。打开一个新的窗口，拷贝qr_check_format、hamming_weight以及qr_decode_format进去，然后保存为qr.py。返回到提示符，输入这些接在&gt;&gt;&gt;后面的这些行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from qr import *</span><br><span class="line">&gt;&gt;&gt; qr_decode_format(int(&quot;000111101011001&quot;,2))  # no errors</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; qr_decode_format(int(&quot;111111101011001&quot;,2))  # 3 bit-errors</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; qr_decode_format(int(&quot;111011101011001&quot;,2))  # 4 bit-errors</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>你也可以通过在命令行提示符中打入python来启动Python。</p>
<p>在接下来的章节中，我们将会学习无限域理论（Finite Field Arithmetics）和Reed–Solomon编码，Reed–Solomon code是BCH编码的一个子类型。基本的思想（也就是，<strong>用一个具有最大可分离性的有限的字典</strong>）是相同的，但是由于我们要编码更长的数据（256字节而非2字节），有很多可用的编码形式（在所有的8比特上编码，因此有256个不同的可能的值），我们不能用这个天真的穷举搜索了，因为这要消耗太多的时间了：我们需要使用一个聪明的算法，并且无限域理论会帮我们做到这一点，仅仅通过给定一个<strong>结构</strong>。</p>
<h1 id="无限域理论"><a href="#无限域理论" class="headerlink" title="无限域理论"></a>无限域理论</h1><h2 id="数学域介绍"><a href="#数学域介绍" class="headerlink" title="数学域介绍"></a>数学域介绍</h2><p>在讨论用于信息编码的Reed–Solomon码之前，我们介绍一点数学基础是有好处的。</p>
<p>我们要为8比特字节定义一套加减乘除运算规则，并且他们的结果也是8比特字节，这是为了避免溢出。天真一点，我们可能会尝试用通常意义上的加减乘除来定义这些操作，然后再把结果模256来使其避免溢出。这也正是我们接下来要做的，这就叫做Galois域2^8。你能想象出来为什么这对什么都管用，却单单对除法不行：7/5等于多少呢？</p>
<p>这里简要介绍下Galois域：<a href="https://en.wikipedia.org/wiki/Finite_field" target="_blank" rel="noopener">无线域（finite field）</a>是一个数字集合，所谓域要包含6个属性：闭合律（Closure），结合律（Associative），分配律（Distributive），恒等（Identity）和可逆性（Inverse）。简单点说，使用域是为了研究这个域中数与数之间的关系，并且把这个结果应用到其他的拥有同样属性的域中。举例来说，实数集ℝ就是一个域。换句话说，<strong>数学域（mathematical fields）</strong>研究一个数字集合的结构。</p>
<p>然而，整数集ℤ就不是一个域了，因为我们上面说过，不是所有的除法都被定义了（比如7/5），这违反了乘法的可逆属性（比如7<em>x=5中的x就不存在）。解决这个问题的一个简单方法就是，用一个质数取模，比如用2：这样，我们就可以保证7</em>x=5是存在的，因为我们马上会给它包装一下。ℤ模2被称为Galois域（Galois Field），并且任何能够被2整除的数都叫Galois域（因为我们需要用质数取模），例如256，一个8比特数的值，就可以简化成2^8，因为我们说我们用了一个2^8的Galois域，或者GF(2^8)。说人话就是，2是这个域的特征（characteristic），而8是指数，256是这个域的势（cardinality）。关于无线域的信息在<a href="http://research.swtch.com/field" target="_blank" rel="noopener">这里</a>。</p>
<p>这里我们将要为Galois域定义那些你用于整数的常用数学操作，但是会适应GF(2^8)，GF(2^8)基本是在做着常用的操作，只是会模2^8而已。</p>
<p>另一个在GF(2)和GF(2^8)之间建立联系的方法是，把GF(2^8)看成代表了一个含有8个二进制系数的多项式。例如，在GF(2^8)中，170等于10101010=1<em>x^7 + 0</em>x^6 + 1<em>x^5 + 0</em>x^4 + 1<em>x^3 + 0</em>x^2 + 1*x + 0 = x^7 + x^5 + x^3 + x。两个表达式是等价的，只是在第一个表达式的情况中170是十进制的，第二个表达式是二进制的，二进制表达式会被约定俗成地看成一个多项式（<a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Effective_polynomial_representation" target="_blank" rel="noopener">用在GF(2^p)上的解释在这里</a>）。后者经常被用在学术书籍和硬件实现中（因为逻辑门电路和寄存器是工作在二进制级别的）。对于软件实现，大家更偏好十进制，因为它写出来的代码更清楚也更接近数学运算（这也是我们这这篇文章中使用的代码的方式，除了那些不得不使用二进制表达式的）。</p>
<p>任何情况下，都不要把这两个东西混为一谈，那就是，代表单个GF(2^p)表达式的多项式（每个系数是一个比特或者说布尔值：0或者1），和代表一系列GF(2^p)表达式的多项式（这种情况下，多项式等同于信息+RS码，每一个系数都是介于0和2^p之间的值，并且表示这个信息+RS码的一个字符）。我们首先讨论单个表达式上的操作，然后才到一系列表达式构成的多项式上的操作。</p>
<h2 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h2><p>在基数为2的Galois域中，加法和减法都用异或来代替了。这是符合逻辑的：加法模2恰好像是XOR操作，减法模2也正好跟加法模2一样。这个之所以可行是因为在Galois域中加减法都是不进位的。（译者注：这里讨论的加减法都是2进制按位加减，且不进位不借位，所以结果等价于异或）</p>
<p>来思考我们的8比特数值作为系数模2的多项式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0101 + 0110 = 0101 - 0110 = 0101 XOR 0110 = 0011</span><br></pre></td></tr></table></figure>
<p>同样的方式（两个单 GF(2^8)整数的二进制表现形式）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x^2 + 1) + (x^2 + x) = 2 x^2 + x + 1 = 0 x^2 + x + 1 = x + 1</span><br></pre></td></tr></table></figure>
<p>由于 (a ^ a) = 0，每个数是它自身的相反数，因此(x-y)等同于(x+y)。</p>
<p>注意在这本书中，你会发现我们用加减法来定义GF整数的数学操作，但是在实践中，你仅仅需要XOR（除非是在Galois域中，其他域中这不是正确的）。</p>
<p>这里是等价的Python代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ^ y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_sub</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x ^ y <span class="comment"># in binary galois field, subtraction is just the same as addition (since we mod 2)</span></span><br></pre></td></tr></table></figure>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>乘法同样地是基于多项式乘法。简单地把输入写成多项式形式，然后像平常一样把它们按照分配律乘开。举个例子，10001001乘以00101010计算如下：</p>
<p><img src="/2018/06/26/Reed–Solomon-codes-for-coders/Multiplication.png" width="500" height="1000" alt="Multiplication"></p>
<p>通过一个改版的小学里教的那种标准乘法我们可以得到相同的结果，其中我们把加用异或代替了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">       10001001</span><br><span class="line">*      00101010</span><br><span class="line">       --------</span><br><span class="line">      10001001</span><br><span class="line">^   10001001</span><br><span class="line">^ 10001001</span><br><span class="line">  --------</span><br><span class="line">  1010001111010</span><br></pre></td></tr></table></figure>
<p>注意：这里的XOR乘法是不进位的！如果你带着进位做，那么你将会得到错误的结果1011001111010，它有着一个额外的项x^9，而正确的结果是1010001111010。</p>
<p>这里给出了一个在单个GF(2^8)整数相乘多项式的Python实现。</p>
<p>注意：这个函数（以及接下来的一些函数）使用了许多二进制操作，例如&gt;&gt;和&lt;&lt;，因为他们都能很快也很简明地执行我们想要的东西。这些操作在很多语言中是可行的，它们不是Python才有的，并且你可以从<a href="https://wiki.python.org/moin/BitwiseOperators" target="_blank" rel="noopener">这里</a>了解到很多信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cl_mul</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="string">'''Bitwise carry-less multiplication on integers'''</span></span><br><span class="line">    z = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (y&gt;&gt;i) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> y &amp; (<span class="number">1</span>&lt;&lt;i):</span><br><span class="line">            z ^= x&lt;&lt;i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go code</span></span><br><span class="line"><span class="comment">// cl_mul 表示证书的按位不进位乘法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cl_mul</span><span class="params">(x, y <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> z <span class="keyword">uint</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">uint</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ; (y &gt;&gt; i) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> y&amp;(<span class="keyword">uint</span>(<span class="number">1</span>)&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">                        z ^= x &lt;&lt; i</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然了，结果不再是8比特字节了（在这个例子中，是13比特），因此我们还要再做一步才算完成。结果要用之前说的长除的方法来通过模100011101（为什么选这个数将会在代码中解释）来约减。在这个例子中，这叫“模约”，因为基本上，我们所做的是通过模来除并保留余数。得到我们例子中的最终结果是11000011。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  1010001111010</span><br><span class="line">^ 100011101</span><br><span class="line">  ---------</span><br><span class="line">  0010110101010</span><br><span class="line">  ^ 100011101</span><br><span class="line">    ---------</span><br><span class="line">    00111011110</span><br><span class="line">    ^ 100011101</span><br><span class="line">      ---------</span><br><span class="line">      011000011</span><br></pre></td></tr></table></figure>
<p>这里是整个带有模约的Galois域乘法的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_mult_noLUT</span><span class="params">(x, y, prim=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''Multiplication in Galois Fields without using a precomputed look-up table (and thus it's slower)</span></span><br><span class="line"><span class="string">    by using the standard carry-less multiplication + modular reduction using an irreducible prime polynomial'''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">### Define bitwise carry-less operations as inner functions ###</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cl_mult</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        <span class="string">'''Bitwise carry-less multiplication on integers'''</span></span><br><span class="line">        z = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (y&gt;&gt;i) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> y &amp; (<span class="number">1</span>&lt;&lt;i):</span><br><span class="line">                z ^= x&lt;&lt;i</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bit_length</span><span class="params">(n)</span>:</span></span><br><span class="line">        <span class="string">'''Compute the position of the most significant bit (1) of an integer. Equivalent to int.bit_length()'''</span></span><br><span class="line">        bits = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;&gt; bits: bits += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cl_div</span><span class="params">(dividend, divisor=None)</span>:</span></span><br><span class="line">        <span class="string">'''Bitwise carry-less long division on integers and returns the remainder'''</span></span><br><span class="line">        <span class="comment"># Compute the position of the most significant bit for each integers</span></span><br><span class="line">        dl1 = bit_length(dividend)</span><br><span class="line">        dl2 = bit_length(divisor)</span><br><span class="line">        <span class="comment"># If the dividend is smaller than the divisor, just exit</span></span><br><span class="line">        <span class="keyword">if</span> dl1 &lt; dl2:</span><br><span class="line">            <span class="keyword">return</span> dividend</span><br><span class="line">        <span class="comment"># Else, align the most significant 1 of the divisor to the most significant 1 of the dividend (by shifting the divisor)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(dl1-dl2,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># Check that the dividend is divisible (useless for the first iteration but important for the next ones)</span></span><br><span class="line">            <span class="keyword">if</span> dividend &amp; (<span class="number">1</span> &lt;&lt; i+dl2<span class="number">-1</span>):</span><br><span class="line">                <span class="comment"># If divisible, then shift the divisor to align the most significant bits and XOR (carry-less subtraction)</span></span><br><span class="line">                dividend ^= divisor &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> dividend</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### Main GF multiplication routine ###</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Multiply the gf numbers</span></span><br><span class="line">    result = cl_mult(x,y)</span><br><span class="line">    <span class="comment"># Then do a modular reduction (ie, remainder from the division) with an irreducible primitive polynomial so that it stays inside GF bounds</span></span><br><span class="line">    <span class="keyword">if</span> prim &gt; <span class="number">0</span>:</span><br><span class="line">        result = cl_div(result, prim)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go code</span></span><br><span class="line"><span class="comment">// cl_mul 表示证书的按位不进位乘法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cl_mul</span><span class="params">(x, y <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> z <span class="keyword">uint</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> i <span class="keyword">uint</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ; (y &gt;&gt; i) &gt; <span class="number">0</span>; i++ &#123;</span><br><span class="line">                <span class="keyword">if</span> y&amp;(<span class="keyword">uint</span>(<span class="number">1</span>)&lt;&lt;i) != <span class="number">0</span> &#123;</span><br><span class="line">                        z ^= x &lt;&lt; i</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bit_length 表示一个整数的有意义的1的位数。相当于int.bit_length()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bit_length</span><span class="params">(n <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> bits <span class="keyword">uint</span></span><br><span class="line">        <span class="keyword">for</span> n&gt;&gt;bits != <span class="number">0</span> &#123;</span><br><span class="line">                bits++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bits</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cl_div 表示按位不进位整数除法，返回余数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cl_div</span><span class="params">(dividend, divisor <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">        dl1 := bit_length(dividend)</span><br><span class="line">        dl2 := bit_length(divisor)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果被除数小于除数，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> dl1 &lt; dl2 &#123;</span><br><span class="line">                <span class="keyword">return</span> dividend</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := dl1 - dl2; <span class="keyword">int</span>(i) &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">                <span class="comment">// 检查被除数是不是可除，第一个迭代没用，但是后续会很重要</span></span><br><span class="line">                <span class="comment">// TODO</span></span><br><span class="line">                fmt.Println(dividend, i)</span><br><span class="line">                <span class="keyword">if</span> (dividend &amp; (<span class="keyword">uint</span>(<span class="number">1</span>) &lt;&lt; (i + dl2 - <span class="number">1</span>))) != <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果可以除，那么就移位除数对齐不为0的位并异或（不进位除）</span></span><br><span class="line">                        dividend = dividend ^ (divisor &lt;&lt; i)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dividend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiply the gf numbers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gf_mult_noLUT</span><span class="params">(x, y, prim <span class="keyword">uint</span>)</span> <span class="title">uint</span></span> &#123;</span><br><span class="line">        result := cl_mul(x, y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> prim &gt; <span class="number">0</span> &#123;</span><br><span class="line">                result = cl_div(result, prim)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 0b10001001</span><br><span class="line">&gt;&gt;&gt; b = 0b00101010</span><br><span class="line">&gt;&gt;&gt; print bin(gf_mult_noLUT(a, b, 0)) # multiplication only</span><br><span class="line">0b1010001111010</span><br><span class="line">&gt;&gt;&gt; print bin(gf_mult_noLUT(a, b, 0x11d)) # multiplication + modular reduction</span><br><span class="line">0b11000011</span><br></pre></td></tr></table></figure>
<p>为什么要模100011101（十六进制是0x11d）呢？数学道理有点复杂，但是简单来说，100011101代表了第八等级不能约多项式（表示它不能被表示成两个小点的多项式的产出）。这个数叫做原始多项式（primitive polynomial）或者不可约多项式（irreducible polynomial），或者质数多项式（prime polynomial）（接下来的文章我们就用最后的这个名字）。除法就是要表现好点，那就是停留在Galois域的范围内，但是不能有重复值。我们还可以选择其他的值，但是他们本质上都是一样的，并且100011101 (0x11d)是一个用于Reed–Solomon编码的常用质数多项式。如果你好奇如何产生那些质数，请看<a href="https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders/Additional_information#Universal_Reed-Solomon_Codec" target="_blank" rel="noopener">附录</a>。</p>
<p>额外的关于质数多项式的信息（你可以跳过这部分）：什么是一个质数多项式？它等价于一个质数，但是要是在Galois域中。记住一个Galois域是乘2得到的构建者（generator）。当然了，一个质数在标准数学中不可能是2的倍数，但是在Galois域中可以的。为什么需要一个质数多项式呢？因为为了停留在域的边界呢，我们需要对任何超出Galois域的值取模。为什么我们不能只是模取Galois域的大小呢？因为我们这么做的话，最终只会得到好多重复的值，我们想要在这个域中获得尽可能多的唯一的值，因此一个数做一个质数多项式的取模运算或者异或运算时候，一般是有且仅有一个投影。</p>
<p>感兴趣的读者注意了：这是一个通过聪明的算法可以做地更好的例子，以下就是一个通过某个方法能够使GF数乘法获得更加简明和快速的方法，这是通过<a href="http://www.cut-the-knot.org/Curriculum/Algebra/PeasantMultiplication.shtml" target="_blank" rel="noopener">俄罗斯农名乘法算法（Russian Peasant Multiplication algorithm）</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_mult_noLUT</span><span class="params">(x, y, prim=<span class="number">0</span>, field_charac_full=<span class="number">256</span>, carryless=True)</span>:</span></span><br><span class="line">    <span class="string">'''Galois Field integer multiplication using Russian Peasant Multiplication algorithm (faster than the standard multiplication + modular reduction).</span></span><br><span class="line"><span class="string">    If prim is 0 and carryless=False, then the function produces the result for a standard integers multiplication (no carry-less arithmetics nor modular reduction).'''</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> y: <span class="comment"># while y is above 0</span></span><br><span class="line">        <span class="keyword">if</span> y &amp; <span class="number">1</span>: r = r ^ x <span class="keyword">if</span> carryless <span class="keyword">else</span> r + x <span class="comment"># y is odd, then add the corresponding x to r (the sum of all x's corresponding to odd y's will give the final product). Note that since we're in GF(2), the addition is in fact an XOR (very important because in GF(2) the multiplication and additions are carry-less, thus it changes the result!).</span></span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span> <span class="comment"># equivalent to y // 2</span></span><br><span class="line">        x = x &lt;&lt; <span class="number">1</span> <span class="comment"># equivalent to x*2</span></span><br><span class="line">        <span class="keyword">if</span> prim &gt; <span class="number">0</span> <span class="keyword">and</span> x &amp; field_charac_full: x = x ^ prim <span class="comment"># GF modulo: if x &gt;= 256 then apply modular reduction using the primitive polynomial (we just subtract, but since the primitive number can be above 256 then we directly XOR).</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>注意了，如果在最后的这个函数中传入prim=0和carryless=False的话，就会得到标准的整数乘法结果（因此，你会看到进位和不进位对于乘法影响的区别）。</p>
<h2 id="基于对数的乘法"><a href="#基于对数的乘法" class="headerlink" title="基于对数的乘法"></a>基于对数的乘法</h2><p>上面描述的过程不是一个实现Galois域最方便的方法。两个数相乘花费了高达8次的乘法循环迭代，伴随着高达8次的乘法循环迭代。然而，我们可以通过使用查询表来实现没有循环的乘法。在内存中构造一个乘法表将会是一个方案，可是那将会需要64k那么大的表。接下来要讲的方法将会紧凑点。</p>
<p>首先，注意到乘以2=00000010是一个特别容易的事情（按照惯例，这个数被称为<strong>α</strong>或者<strong>构建者数(generator number)</strong>）：简单地左移一位，然后再用模100011101异或如果需要的话（为什么说在我们的例子中XOR对于取模来说已经足够了，这个问题作为练习留给读者）。这里给出α的一些幂值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">α^0 = 00000001	α^4 = 00010000	α^8  = 00011101	α^12 = 11001101</span><br><span class="line">α^1 = 00000010	α^5 = 00100000	α^9  = 00111010	α^13 = 10000111</span><br><span class="line">α^2 = 00000100	α^6 = 01000000	α^10 = 01110100	α^14 = 00010011</span><br><span class="line">α^3 = 00001000	α^7 = 10000000	α^11 = 11101000	α^15 = 00100110</span><br></pre></td></tr></table></figure>
<p>如果这个表格照这个样子类推下去，α的幂都不会重复，除非到了α^255 = 00000001。因此这个域中的每个值，除了0以外，都是α的某次幂。我们定义出来的元素α就被认为是<a href="https://en.wikipedia.org/wiki/Primitive_element_(finite_field" target="_blank" rel="noopener">原始元素(primitive element)</a>)或者Galois域构造者。</p>
<p>观察发现另外一种方法来实现乘法：通过α的指数加法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10001001 * 00101010 = α^74 * α^142 = α^(74 + 142) = α^216 = 11000011</span><br></pre></td></tr></table></figure>
<p>问题来了，我们怎么找到和10001001对应的 α 的幂呢？这个就是被称为<a href="https://en.wikipedia.org/wiki/Discrete_logarithm" target="_blank" rel="noopener">离散数学（discrete logarithm）</a>问题，而且没有已知的特别有效的解决方案。然后，因为这个域中只有256个元素，我们可以很容易地构建一个对数表。与此同时，一个对应的反对数（指数）表也是有用的。更多有用的信息可以参阅<a href="https://en.wikipedia.org/wiki/Finite_field_arithmetic#Implementation_tricks" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">gf_exp = [<span class="number">0</span>] * <span class="number">512</span> <span class="comment"># Create list of 512 elements. In Python 2.6+, consider using bytearray</span></span><br><span class="line">gf_log = [<span class="number">0</span>] * <span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_tables</span><span class="params">(prim=<span class="number">0x11d</span>)</span>:</span></span><br><span class="line">    <span class="string">'''Precompute the logarithm and anti-log tables for faster computation later, using the provided primitive polynomial.'''</span></span><br><span class="line">    <span class="comment"># prim is the primitive (binary) polynomial. Since it's a polynomial in the binary sense,</span></span><br><span class="line">    <span class="comment"># it's only in fact a single galois field value between 0 and 255, and not a list of gf values.</span></span><br><span class="line">    <span class="keyword">global</span> gf_exp, gf_log</span><br><span class="line">    gf_exp = [<span class="number">0</span>] * <span class="number">512</span> <span class="comment"># anti-log (exponential) table</span></span><br><span class="line">    gf_log = [<span class="number">0</span>] * <span class="number">256</span> <span class="comment"># log table</span></span><br><span class="line">    <span class="comment"># For each possible value in the galois field 2^8, we will pre-compute the logarithm and anti-logarithm (exponential) of this value</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">255</span>):</span><br><span class="line">        gf_exp[i] = x <span class="comment"># compute anti-log for this value and store it in a table</span></span><br><span class="line">        gf_log[x] = i <span class="comment"># compute log at the same time</span></span><br><span class="line">        x = gf_mult_noLUT(x, <span class="number">2</span>, prim)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If you use only generator==2 or a power of 2, you can use the following which is faster than gf_mult_noLUT():</span></span><br><span class="line">        <span class="comment">#x &lt;&lt;= 1 # multiply by 2 (change 1 by another number y to multiply by a power of 2^y)</span></span><br><span class="line">        <span class="comment">#if x &amp; 0x100: # similar to x &gt;= 256, but a lot faster (because 0x100 == 256)</span></span><br><span class="line">            <span class="comment">#x ^= prim # substract the primary polynomial to the current value (instead of 255, so that we get a unique set made of coprime numbers), this is the core of the tables generation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Optimization: double the size of the anti-log table so that we don't need to mod 255 to</span></span><br><span class="line">    <span class="comment"># stay inside the bounds (because we will mainly use this table for the multiplication of two GF numbers, no more).</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>, <span class="number">512</span>):</span><br><span class="line">        gf_exp[i] = gf_exp[i - <span class="number">255</span>]</span><br><span class="line">    <span class="keyword">return</span> [gf_log, gf_exp]</span><br></pre></td></tr></table></figure>
<p>Python注意事项：range操作符的右括号是开放的，因此gf_exp[255]没有被赋值两次。</p>
<p>gf_exp表示超过大小的，因为为了简化乘法函数。这样的话，我们就不必要去检查从而确信gf_log[x] + gf_log[y]在这个表的大小范围内了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_mul</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span> <span class="keyword">or</span> y==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> gf_exp[gf_log[x] + gf_log[y]] <span class="comment"># should be gf_exp[(gf_log[x]+gf_log[y])%255] if gf_exp wasn't oversized</span></span><br></pre></td></tr></table></figure>
<h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>另外一个对数表方法的优势是，它允许我们通过幂的差来定义除法。在下面的代码中，加上255是为了确保差不是负数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_div</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> y==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ZeroDivisionError()</span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> gf_exp[(gf_log[x] + <span class="number">255</span> - gf_log[y]) % <span class="number">255</span>]</span><br></pre></td></tr></table></figure>
<p>Python注意事项：raise语句抛出一个异常，并终止gf_div函数的执行。</p>
<p>根据除法的定义，<code>gf_div(gf_mul(x,y),y)==x</code>对于任何的x和非零y都是成立的。</p>
<p>读者中的高级程序员可能会觉得写一个Galois域算法的封装是有意思的。<a href="https://en.wikipedia.org/wiki/Operator_overloading" target="_blank" rel="noopener">操作符重载（Operator overloading）</a>可以用来使用大家熟悉的*和/来代替对于gf_mul和gf_div的调用，但是这会导致微妙究竟在执行什么操作的困惑。这样的细节可以以使得这个类更加广泛使用的方式推广。例如，<a href="https://en.wikipedia.org/wiki/Aztec_Code" target="_blank" rel="noopener">Aztec编码</a>采用了5个不同的元素大小从4比特到12比特不等的Galois域。</p>
<h2 id="幂和倒数"><a href="#幂和倒数" class="headerlink" title="幂和倒数"></a>幂和倒数</h2><p>当我们计算幂和倒数的时候，对数表方法再一次地简化和加速了我们的计算过程。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_pow</span><span class="params">(x, power)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> gf_exp[(gf_log[x] * power) % <span class="number">255</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_inverse</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> gf_exp[<span class="number">255</span> - gf_log[x]] <span class="comment"># gf_inverse(x) == gf_div(1, x)</span></span><br></pre></td></tr></table></figure>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>在接续探讨Reed–Solomon前，我们需要来定义几个系数是Galois域元素的多项的操作。这里有一个潜在的导致混淆的根源，因为元素本身也是被描述成多项式的；我的建议是不要想太多了。导致混淆更加厉害的是，x也被用成了占位符。这里的x跟我们之前说的x没有半毛钱关系，因此不要把它们搞混了。</p>
<p>之前用于Galois域元素的二进制表达方法在这里变得笨重而不便了，因此我将换用十六进制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000001 x^4 + 00001111 x^3 + 00110110 x^2 + 01111000 x + 01000000 = 01 x^4 + 0f x^3 + 36 x^2 + 78 x + 40</span><br></pre></td></tr></table></figure>
<p>在python中，多项式被表示成一系列降序幂的数字集合，因此上面的多项式变成了[ 0x01, 0x0f, 0x36, 0x78, 0x40 ]。（反序表达也被用过的，两种方法各有优劣。）</p>
<p>第一次函数将一个多项式跟一个标量相乘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_poly_scale</span><span class="params">(p,x)</span>:</span></span><br><span class="line">    r = [<span class="number">0</span>] * len(p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(p)):</span><br><span class="line">        r[i] = gf_mul(p[i], x)</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gf_poly_scale</span><span class="params">(p []<span class="keyword">uint</span>, x <span class="keyword">uint</span>)</span> []<span class="title">uint</span></span> &#123;</span><br><span class="line">        r := <span class="built_in">make</span>([]<span class="keyword">uint</span>, <span class="built_in">len</span>(p))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">                r[i] = gf_mul(p[i], x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python程序员注意了，这个函数写得不像Python。它本可以用<a href="https://en.wikipedia.org/wiki/List_comprehension" target="_blank" rel="noopener">列表理解（list comprehension）</a>写得更加优雅一点，但是在语言特性上我限制了我自己，这样它们可以被很容易地转成其他的编程语言。</p>
<p>这个函数把两个多项式“加”起来了（跟往常一样，用了异或）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_poly_add</span><span class="params">(p,q)</span>:</span></span><br><span class="line">    r = [<span class="number">0</span>] * max(len(p),len(q))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(p)):</span><br><span class="line">        r[i+len(r)-len(p)] = p[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(q)):</span><br><span class="line">        r[i+len(r)-len(q)] ^= q[i]</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go code</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gf_poly_add</span><span class="params">(p, q []<span class="keyword">uint</span>)</span> []<span class="title">uint</span></span> &#123;</span><br><span class="line">        max := <span class="built_in">len</span>(p)</span><br><span class="line">        <span class="keyword">if</span> max &lt; <span class="built_in">len</span>(q) &#123;</span><br><span class="line">                max = <span class="built_in">len</span>(q)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r := <span class="built_in">make</span>([]<span class="keyword">uint</span>, max)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">                r[i+<span class="built_in">len</span>(r)-<span class="built_in">len</span>(p)] = p[i] <span class="comment">// 译注：右对齐，不管pq谁长谁短，一致处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(q); i++ &#123;</span><br><span class="line">                r[i+<span class="built_in">len</span>(r)-<span class="built_in">len</span>(p)] ^= q[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的方程将两个多项式相乘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_poly_mul</span><span class="params">(p,q)</span>:</span></span><br><span class="line">    <span class="string">'''Multiply two polynomials, inside Galois Field'''</span></span><br><span class="line">    <span class="comment"># Pre-allocate the result array</span></span><br><span class="line">    r = [<span class="number">0</span>] * (len(p)+len(q)<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># Compute the polynomial multiplication (just like the outer product of two vectors,</span></span><br><span class="line">    <span class="comment"># we multiply each coefficients of p with all coefficients of q)</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(q)):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(p)):</span><br><span class="line">            r[i+j] ^= gf_mul(p[i], q[j]) <span class="comment"># equivalent to: r[i + j] = gf_add(r[i+j], gf_mul(p[i], q[j]))</span></span><br><span class="line">                                                         <span class="comment"># -- you can see it's your usual polynomial multiplication</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
<p>最后，我们需要一个函数来针对给定x的值求出多项式的标量值。<a href="https://en.wikipedia.org/wiki/Horner%27s_method" target="_blank" rel="noopener">Horner的方法</a>可以用来避免显示计算x的幂。Horner方法原理是通过连续的因式分解，从而我们一直是处理x^1，因而避免了计算高阶的项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01x^4 + 0f x^3 + 36 x^2 + 78 x + 40 = (((01 x + 0f) x + 36) x + 78) x + 40</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_poly_eval</span><span class="params">(poly, x)</span>:</span></span><br><span class="line">    <span class="string">'''Evaluates a polynomial in GF(2^p) given the value for x. This is based on Horner's scheme for maximum efficiency.'''</span></span><br><span class="line">    y = poly[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(poly)):</span><br><span class="line">        y = gf_mul(y, x) ^ poly[i]</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>
<p>还剩下一个我们需要的多项式操作：多项式除法。这个比其他的多项式操作要复杂些，因此我们将在下一章来学习它，和Reed–Solomon编码一起。</p>
<h1 id="Reed–Solomon编码"><a href="#Reed–Solomon编码" class="headerlink" title="Reed–Solomon编码"></a>Reed–Solomon编码</h1><p>现在预赛已经可以起开了，我们准备开始看Reed–Solomon编码。</p>
<h2 id="编码理论透析"><a href="#编码理论透析" class="headerlink" title="编码理论透析"></a>编码理论透析</h2><p>但是首先，我们为什么前面要学无限域和多项式呢？因为，这是想Reed–Solomon这样的纠错码的精髓：我们不是把信息看成一系列ASCII数字，而是自带精心定义的<strong>无限域算法规则</strong>的<strong>多项式</strong>。换句话说，通过使用多项式和无限域理论和呈现数据，<strong>我们为数据增加了一个结构</strong>。信息的值还是一样的，但是这种附着其上的结构概念可以让我们用精心定义的数学规则来操作这些信息，操作这些字符。这个结构，就是我们一直知道的因为它独立于数据之外，它可以让我们得以修复受损的信息。</p>
<p>那么，即便是在你的代码实现中，你都不会选择显式地出现多项式和无限域理论，这些理论本质上是为了纠错码能够工作，并且你会发现这些理论是任何实现的基础（甚至是隐含的）。</p>
<p>那么我们来将这些理论付诸实践吧。</p>
<h2 id="RS编码"><a href="#RS编码" class="headerlink" title="RS编码"></a>RS编码</h2><h3 id="编码概述"><a href="#编码概述" class="headerlink" title="编码概述"></a>编码概述</h3><p>类似于BCH码，Reed–Solomon通过使用不可约构建者多项式（irreducible generator polynomial）来分解代表信息数据的多项式，从而达到编码的目的，那么余数就是RS码，我们会把这个余数追加在原始信息之后。</p>
<p>为什么要这么做呢？我们先前说过，BCH编码以及其他的大多数纠错编码背后的原理是，通过使用一个带有区分度很大的信息元的简化字典来使得信息之间的距离，信息元越长其距离越大：这里是同样的原理，首先我们用额外的编码（余数）加长了原始信息，其次因为余数基本都是唯一的（多亏了小心定义的不可约构建者多项式），那么我们就可以利用精巧的算法来推断部分的原始信息。</p>
<p>用一个加密的近似类比来总结一下：我们说的<strong>构建者多项式</strong>就是我们的加密字典，而<strong>多项式分解</strong>就是通过字典（构建者多项式）把信息<strong>转化</strong>为RS码的操作。</p>
<h3 id="异常管理"><a href="#异常管理" class="headerlink" title="异常管理"></a>异常管理</h3><p>为了管理错误以及我们不能纠正一个信息的情况，我们要显示一个有意义的错误信息，就是通过抛出一个异常。我们将要来搞出我们自定义的一套异常，那么用户可以很容易地捕获和管理他们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReedSolomonError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>为了通过抛出我们自定义的异常来显示错误，我们可以简单地这么做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> ReedSolomonError(<span class="string">"Some error message"</span>)</span><br></pre></td></tr></table></figure>
<p>然后你可以非常容易地通过try/except块捕获这个异常从而处理它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> ReedSolomonError(<span class="string">"Some error message"</span>)</span><br><span class="line"><span class="keyword">except</span> ReedSolomonError, e:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># do something here</span></span><br></pre></td></tr></table></figure>
<h3 id="RS构建者多项式"><a href="#RS构建者多项式" class="headerlink" title="RS构建者多项式"></a>RS构建者多项式</h3><p>Reed–Solomon编码使用了一个跟BCH编码类似的<strong>构建者</strong>多项式（别和构建者数字字母混淆起来）。构建者是(x - α^n)因子的产物，QR码就是从n=0开始的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g4(x) = (x - α^0) (x - α^1) (x - α^2) (x - α^3) = 01 x^4 + 0f x^3 + 36 x^2 + 78 x + 40</span><br></pre></td></tr></table></figure>
<p>这里给出了一个函数可以用来计算给定数目的错误纠正符的构建者多项式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rs_generator_poly</span><span class="params">(nsym)</span>:</span></span><br><span class="line">    <span class="string">'''Generate an irreducible generator polynomial (necessary to encode a message into Reed-Solomon)'''</span></span><br><span class="line">    g = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, nsym):</span><br><span class="line">        g = gf_poly_mul(g, [<span class="number">1</span>, gf_pow(<span class="number">2</span>, i)])</span><br><span class="line">    <span class="keyword">return</span> g</span><br></pre></td></tr></table></figure>
<p>这个函数某种程度上不是很高效，因为它每次都是分配了更大的数组给g。虽然这不太可能在实践中形成性能问题，有优化习惯的读者可能觉得重写它使g只被分配一次是有意思的，或者你能计算一次然后把g存在内存中，因为对于一个给定的nsym来说g是固定的，因此你可以重用g。</p>
<h3 id="多项式除法"><a href="#多项式除法" class="headerlink" title="多项式除法"></a>多项式除法</h3><p>多项式除法有很多个存在的算法，最简单的莫过于高中时候教的<a href="https://en.wikipedia.org/wiki/Polynomial_long_division" target="_blank" rel="noopener">长除(long division)</a>。这个例子展示了信息<code>12 34 56</code>的计算过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                             12 da df</span><br><span class="line">               ______________________</span><br><span class="line">01 0f 36 78 40 ) 12 34 56 00 00 00 00</span><br><span class="line">               ^ 12 ee 2b 23 f4</span><br><span class="line">                 --------------</span><br><span class="line">                    da 7d 23 f4 00</span><br><span class="line">                  ^ da a2 85 79 84</span><br><span class="line">                    --------------</span><br><span class="line">                       df a6 8d 84 00</span><br><span class="line">                     ^ df 91 6b fc d9</span><br><span class="line">                       --------------</span><br><span class="line">                          37 e6 78 d9</span><br></pre></td></tr></table></figure>
<p>注意：这一开始可能看起来比较复杂，但是这和你做以10为基数的多项式长除工作起来没有什么两样，它只是以10为基数而已（十六进制）。如果你理解这个例子起来有困难，你可以把这些数字转换成以10为基数，然后你马上就会看到结果是理所当然的了。</p>
<p>余数和信息本身被串联起来了，因此编码过的信息是<code>12 34 56 37 e6 78 d9</code>。</p>
<p>然而，长除是很慢的，因为它需要很多循环迭代来得到结果。更高效的策略可以被发明出来，例如使用<a href="https://en.wikiversity.org/wiki/Synthetic_division" target="_blank" rel="noopener">综合除法（synthetic division）</a>（也叫Horner法，一个很好的学习视频在<a href="https://www.khanacademy.org/math/algebra2/polynomial_and_rational/synthetic-division/v/synthetic-division" target="_blank" rel="noopener">这里</a>）。这里有一个函数实现了GF(2^p)多项式的扩展综合除法（扩展是因为除数是一个多项式而不是一个单项）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gf_poly_div</span><span class="params">(dividend, divisor)</span>:</span></span><br><span class="line">    <span class="string">'''Fast polynomial division by using Extended Synthetic Division and optimized for GF(2^p) computations</span></span><br><span class="line"><span class="string">    (doesn't work with standard polynomials outside of this galois field, see the Wikipedia article for generic algorithm).'''</span></span><br><span class="line">    <span class="comment"># CAUTION: this function expects polynomials to follow the opposite convention at decoding:</span></span><br><span class="line">    <span class="comment"># the terms must go from the biggest to lowest degree (while most other functions here expect</span></span><br><span class="line">    <span class="comment"># a list from lowest to biggest degree). eg: 1 + 2x + 5x^2 = [5, 2, 1], NOT [1, 2, 5]</span></span><br><span class="line"></span><br><span class="line">    msg_out = list(dividend) <span class="comment"># Copy the dividend</span></span><br><span class="line">    <span class="comment">#normalizer = divisor[0] # precomputing for performance</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(dividend) - (len(divisor)<span class="number">-1</span>)):</span><br><span class="line">        <span class="comment">#msg_out[i] /= normalizer # for general polynomial division (when polynomials are non-monic), the usual way of using</span></span><br><span class="line">                                  <span class="comment"># synthetic division is to divide the divisor g(x) with its leading coefficient, but not needed here.</span></span><br><span class="line">        coef = msg_out[i] <span class="comment"># precaching</span></span><br><span class="line">        <span class="keyword">if</span> coef != <span class="number">0</span>: <span class="comment"># log(0) is undefined, so we need to avoid that case explicitly (and it's also a good optimization).</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(divisor)): <span class="comment"># in synthetic division, we always skip the first coefficient of the divisior,</span></span><br><span class="line">                                              <span class="comment"># because it's only used to normalize the dividend coefficient</span></span><br><span class="line">                <span class="keyword">if</span> divisor[j] != <span class="number">0</span>: <span class="comment"># log(0) is undefined</span></span><br><span class="line">                    msg_out[i + j] ^= gf_mul(divisor[j], coef) <span class="comment"># equivalent to the more mathematically correct</span></span><br><span class="line">                                                               <span class="comment"># (but xoring directly is faster): msg_out[i + j] += -divisor[j] * coef</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The resulting msg_out contains both the quotient and the remainder, the remainder being the size of the divisor</span></span><br><span class="line">    <span class="comment"># (the remainder has necessarily the same degree as the divisor -- not length but degree == length-1 -- since it's</span></span><br><span class="line">    <span class="comment"># what we couldn't divide from the dividend), so we compute the index where this separation is, and return the quotient and remainder.</span></span><br><span class="line">    separator = -(len(divisor)<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> msg_out[:separator], msg_out[separator:] <span class="comment"># return quotient, remainder.</span></span><br></pre></td></tr></table></figure>
<h3 id="Encoding-main-function"><a href="#Encoding-main-function" class="headerlink" title="Encoding main function"></a>Encoding main function</h3><p>现在，这里给出一个如何编码一个信息获得一个RS编码的方法的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rs_encode_msg</span><span class="params">(msg_in, nsym)</span>:</span></span><br><span class="line">    <span class="string">'''Reed-Solomon main encoding function'''</span></span><br><span class="line">    gen = rs_generator_poly(nsym)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Pad the message, then divide it by the irreducible generator polynomial</span></span><br><span class="line">    _, remainder = gf_poly_div(msg_in + [<span class="number">0</span>] * (len(gen)<span class="number">-1</span>), gen)</span><br><span class="line">    <span class="comment"># The remainder is our RS code! Just append it to our original message to get our full codeword (this represents a polynomial of max 256 terms)</span></span><br><span class="line">    msg_out = msg_in + remainder</span><br><span class="line">    <span class="comment"># Return the codeword</span></span><br><span class="line">    <span class="keyword">return</span> msg_out</span><br></pre></td></tr></table></figure>
<p>很简单，是不是？加密其实是Reed–Solomon中最简单的部分，并且总是用同样的方法（多项式除法）。解码是Reed–Solomon中最难的部分，你会发现根据你的需要不同而有很多不同的算法，但是我们一会再碰这个。</p>
<p>这个函数是很快的，但是对于实用还是太慢了，特别是在Python中。还有一些使用各种各样技巧的方法来优化速度。</p>
<p>(未完待续)</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lylex</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/your-user-name" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter"><i class="fa fa-fw fa-globe"></i>Twitter</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://qianzhou.tech/" title="Home" target="_blank">Home</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lylex</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  












  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
